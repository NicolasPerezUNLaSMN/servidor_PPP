// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Obra.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Obra TABLE
class TableObra extends SqfEntityTableBase {
  TableObra() {
    // declare properties of EntityTable
    tableName = 'obra';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('nombreRepresentanteOSC', DbType.text),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableObra();
  }
}

// Vivienda TABLE
class TableVivienda extends SqfEntityTableBase {
  TableVivienda() {
    // declare properties of EntityTable
    tableName = 'vivienda';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('aliasRenabap', DbType.text),
      SqfEntityFieldBase('viviendaId', DbType.text),
      SqfEntityFieldBase('metrosCuadrados', DbType.integer),
      SqfEntityFieldBase('ambientes', DbType.integer),
      SqfEntityFieldBase('directoACalle', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('servicioCloacas', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('servicioLuz', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('servicioAgua', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('servicioGas', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('servicioInternet', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('reubicados', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('titular', DbType.text),
      SqfEntityFieldBase('contactoJefeHogar', DbType.text),
      SqfEntityFieldBase('contactoReferencia', DbType.text),
      SqfEntityFieldBase('jefeHogarNombre', DbType.text),
      SqfEntityFieldBase('cantHabitantes', DbType.integer),
      SqfEntityFieldBase('habitantesAdultos', DbType.integer),
      SqfEntityFieldBase('habitantesMenores', DbType.integer),
      SqfEntityFieldBase('habitantesMayores', DbType.integer),
      SqfEntityFieldBase('duenosVivienda', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('preguntasPgas', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('cuestionarioHabitabilidad', DbType.bool,
          defaultValue: false, isNotNull: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVivienda();
  }
}

// Ubicacion TABLE
class TableUbicacion extends SqfEntityTableBase {
  TableUbicacion() {
    // declare properties of EntityTable
    tableName = 'ubicacion';
    relationType = RelationType.ONE_TO_ONE;

    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('region', DbType.text),
      SqfEntityFieldBase('provincia', DbType.text),
      SqfEntityFieldBase('localidad', DbType.text),
      SqfEntityFieldBase('barrio', DbType.text),
      SqfEntityFieldBase('direccion', DbType.text),
      SqfEntityFieldBase('planta', DbType.text),
      SqfEntityFieldBase('latitud', DbType.real),
      SqfEntityFieldBase('longitud', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableVivienda.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_ONE,
          fieldName: '_id',
          isPrimaryKeyField: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUbicacion();
  }
}

// Certificado TABLE
class TableCertificado extends SqfEntityTableBase {
  TableCertificado() {
    // declare properties of EntityTable
    tableName = 'certificado';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('monto', DbType.real),
      SqfEntityFieldBase('fecha', DbType.date,
          isNotNull: true, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('pdf', DbType.blob),
      SqfEntityFieldBase('cargadoServidor', DbType.bool, defaultValue: false),
      SqfEntityFieldRelationshipBase(TableObra.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'obraId',
          isNotNull: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCertificado();
  }
}

// Visita TABLE
class TableVisita extends SqfEntityTableBase {
  TableVisita() {
    // declare properties of EntityTable
    tableName = 'visita';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('numVisita', DbType.integer, isNotNull: true),
      SqfEntityFieldBase('informeId', DbType.integer),
      SqfEntityFieldBase('fecha', DbType.date,
          defaultValue: DateTime.now(),
          minValue: DateTime.parse('2021-01-01'),
          maxValue: DateTime.now().add(Duration(days: 30))),
      SqfEntityFieldBase('nombreRelevador', DbType.text, isNotNull: true),
      SqfEntityFieldBase('observaciones', DbType.text),
      SqfEntityFieldBase('visitaFinal', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('cargadoServidor', DbType.bool, defaultValue: false),
      SqfEntityFieldRelationshipBase(TableObra.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'obraId',
          isNotNull: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVisita();
  }
}

// PreguntaVisita TABLE
class TablePreguntaVisita extends SqfEntityTableBase {
  TablePreguntaVisita() {
    // declare properties of EntityTable
    tableName = 'preguntaVisita';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('tipoRespuestaA', DbType.text),
      SqfEntityFieldBase('tipoRespuestaB', DbType.text),
      SqfEntityFieldBase('tipoRespuestaC', DbType.text),
      SqfEntityFieldBase('esTexto', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('pregunta', DbType.text, isNotNull: true),
      SqfEntityFieldBase('cuestionarioHabitabilidad', DbType.bool,
          defaultValue: false),
      SqfEntityFieldBase('etapaDeAvance', DbType.integer, defaultValue: 0),
      SqfEntityFieldRelationshipBase(
          TableIntervencion.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'intervencionId'),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePreguntaVisita();
  }
}

// RespuestaVisita TABLE
class TableRespuestaVisita extends SqfEntityTableBase {
  TableRespuestaVisita() {
    // declare properties of EntityTable
    tableName = 'respuestaVisita';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('respuesta', DbType.text, isNotNull: true),
      SqfEntityFieldBase('puntaje', DbType.real, defaultValue: -1),
      SqfEntityFieldBase('pgas', DbType.bool, defaultValue: false),
      SqfEntityFieldRelationshipBase(
          TablePreguntaVisita.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'preguntaVisitaId',
          isNotNull: true),
      SqfEntityFieldBase('nroComponente', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableVivienda.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'viviendaId'),
      SqfEntityFieldRelationshipBase(
          TableVisita.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'visitaId'),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRespuestaVisita();
  }
}

// Intervencion TABLE
class TableIntervencion extends SqfEntityTableBase {
  TableIntervencion() {
    // declare properties of EntityTable
    tableName = 'intervencion';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('nombre', DbType.text, isNotNull: true),
      SqfEntityFieldBase('esPgas', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIntervencion();
  }
}

// FotoVisita TABLE
class TableFotoVisita extends SqfEntityTableBase {
  TableFotoVisita() {
    // declare properties of EntityTable
    tableName = 'fotoVisita';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('imagen', DbType.blob, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableVisita.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'visitaId',
          isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableIntervencion.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'intervencionId'),
      SqfEntityFieldBase('nroComponente', DbType.integer),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFotoVisita();
  }
}

// FotoVivienda TABLE
class TableFotoVivienda extends SqfEntityTableBase {
  TableFotoVivienda() {
    // declare properties of EntityTable
    tableName = 'fotoVivienda';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('imagen', DbType.blob, isNotNull: true),
      SqfEntityFieldBase('fotoPrincipal', DbType.bool, isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableVivienda.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'viviendaId',
          isNotNull: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFotoVivienda();
  }
}

// DocumentacionTecnica TABLE
class TableDocumentacionTecnica extends SqfEntityTableBase {
  TableDocumentacionTecnica() {
    // declare properties of EntityTable
    tableName = 'documentacionTecnica';
    relationType = RelationType.ONE_TO_ONE;

    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('datos', DbType.blob),
      SqfEntityFieldBase('computo', DbType.blob),
      SqfEntityFieldBase('planosDeObra', DbType.blob),
      SqfEntityFieldBase('cuadrillaDeTrabajadores', DbType.blob),
      SqfEntityFieldBase('sintesisDiagnosticoDeViviendas', DbType.blob),
      SqfEntityFieldBase('certificadoAvanceObra', DbType.blob),
      SqfEntityFieldBase('planDeObra', DbType.blob),
      SqfEntityFieldBase('diagramaGantt', DbType.blob),
      SqfEntityFieldRelationshipBase(TableObra.getInstance, DeleteRule.SET_NULL,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'obraId',
          isNotNull: true),
      SqfEntityFieldRelationshipBase(
          TableVivienda.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_ONE,
          fieldName: '_id',
          isPrimaryKeyField: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDocumentacionTecnica();
  }
}

// Obra_intervencion TABLE
class TableObra_intervencion extends SqfEntityTableBase {
  TableObra_intervencion() {
    // declare properties of EntityTable
    tableName = 'obra_intervencion';

    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('nroComponente', DbType.integer,
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TableIntervencion.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'intervencionId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(TableObra.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'obraId',
          isPrimaryKeyField: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableObra_intervencion();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class MyDbModel extends SqfEntityModelProvider {
  MyDbModel() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TableObra.getInstance,
      TableVivienda.getInstance,
      TableUbicacion.getInstance,
      TableCertificado.getInstance,
      TableVisita.getInstance,
      TablePreguntaVisita.getInstance,
      TableRespuestaVisita.getInstance,
      TableIntervencion.getInstance,
      TableFotoVisita.getInstance,
      TableFotoVivienda.getInstance,
      TableDocumentacionTecnica.getInstance,
      TableObra_intervencion.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};
    controllers['obra'] = ObraController.getController;
    controllers['vivienda'] = ViviendaController.getController;
    controllers['certificado'] = CertificadoController.getController;
    controllers['visita'] = VisitaController.getController;
    controllers['preguntavisita'] = PreguntaVisitaController.getController;
    controllers['respuestavisita'] = RespuestaVisitaController.getController;
    controllers['intervencion'] = IntervencionController.getController;
    controllers['fotovisita'] = FotoVisitaController.getController;
    controllers['fotovivienda'] = FotoViviendaController.getController;

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Obra
class Obra extends TableBase {
  Obra({this.id, this.nombreRepresentanteOSC, this.dateCreated}) {
    _setDefaultValues();
  }
  Obra.withFields(this.id, this.nombreRepresentanteOSC, this.dateCreated) {
    _setDefaultValues();
  }
  Obra.withId(this.id, this.nombreRepresentanteOSC, this.dateCreated) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Obra.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['nombreRepresentanteOSC'] != null) {
      nombreRepresentanteOSC = o['nombreRepresentanteOSC'].toString();
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Obra)
  int? id;
  String? nombreRepresentanteOSC;
  DateTime? dateCreated;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Obra)

// COLLECTIONS & VIRTUALS (Obra)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCertificados', 'plField2'..]) or so on..
  List<Certificado>? plCertificados;

  /// get Certificado(s) filtered by id=obraId
  CertificadoFilterBuilder? getCertificados(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Certificado()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .obraId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVisitas', 'plField2'..]) or so on..
  List<Visita>? plVisitas;

  /// get Visita(s) filtered by id=obraId
  VisitaFilterBuilder? getVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Visita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .obraId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plDocumentacionTecnicas', 'plField2'..]) or so on..
  List<DocumentacionTecnica>? plDocumentacionTecnicas;

  /// get DocumentacionTecnica(s) filtered by id=obraId
  DocumentacionTecnicaFilterBuilder? getDocumentacionTecnicas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DocumentacionTecnica()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .obraId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plObra_intervencions', 'plField2'..]) or so on..
  List<Obra_intervencion>? plObra_intervencions;

  /// get Obra_intervencion(s) filtered by id=obraId
  Obra_intervencionFilterBuilder? getObra_intervencions(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Obra_intervencion()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .obraId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Obra)

  static const bool _softDeleteActivated = false;
  ObraManager? __mnObra;

  ObraManager get _mnObra {
    return __mnObra = __mnObra ?? ObraManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['nombreRepresentanteOSC'] = nombreRepresentanteOSC;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['nombreRepresentanteOSC'] = nombreRepresentanteOSC;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }

// COLLECTIONS (Obra)
    if (!forQuery) {
      map['Certificados'] = await getCertificados()!.toMapList();
    }
    if (!forQuery) {
      map['Visitas'] = await getVisitas()!.toMapList();
    }
    if (!forQuery) {
      map['DocumentacionTecnicas'] =
          await getDocumentacionTecnicas()!.toMapList();
    }
    if (!forQuery) {
      map['Obra_intervencions'] = await getObra_intervencions()!.toMapList();
    }
// END COLLECTIONS (Obra)

    return map;
  }

  /// This method returns Json String [Obra]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Obra]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      nombreRepresentanteOSC,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      nombreRepresentanteOSC,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Obra>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Obra.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Obra>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Obra>[];
    try {
      objList = list
          .map((obra) => Obra.fromMap(obra as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Obra.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Obra>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Obra> objList = <Obra>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Obra.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plCertificados') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCertificados'))) {
          /*_loadedfields!.add('obra.plCertificados'); */ obj.plCertificados =
              obj.plCertificados ??
                  await obj.getCertificados()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVisitas'))) {
          /*_loadedfields!.add('obra.plVisitas'); */ obj.plVisitas =
              obj.plVisitas ??
                  await obj.getVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plDocumentacionTecnicas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDocumentacionTecnicas'))) {
          /*_loadedfields!.add('obra.plDocumentacionTecnicas'); */ obj
                  .plDocumentacionTecnicas =
              obj.plDocumentacionTecnicas ??
                  await obj.getDocumentacionTecnicas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plObra_intervencions') && */ (preloadFields ==
                null ||
            preloadFields.contains('plObra_intervencions'))) {
          /*_loadedfields!.add('obra.plObra_intervencions'); */ obj
                  .plObra_intervencions =
              obj.plObra_intervencions ??
                  await obj.getObra_intervencions()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Obra by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Obra] if exist, otherwise returns null
  Future<Obra?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Obra? obj;
    final data = await _mnObra.getById([id]);
    if (data.length != 0) {
      obj = Obra.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plCertificados') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCertificados'))) {
          /*_loadedfields!.add('obra.plCertificados'); */ obj.plCertificados =
              obj.plCertificados ??
                  await obj.getCertificados()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVisitas'))) {
          /*_loadedfields!.add('obra.plVisitas'); */ obj.plVisitas =
              obj.plVisitas ??
                  await obj.getVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plDocumentacionTecnicas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDocumentacionTecnicas'))) {
          /*_loadedfields!.add('obra.plDocumentacionTecnicas'); */ obj
                  .plDocumentacionTecnicas =
              obj.plDocumentacionTecnicas ??
                  await obj.getDocumentacionTecnicas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plObra_intervencions') && */ (preloadFields ==
                null ||
            preloadFields.contains('plObra_intervencions'))) {
          /*_loadedfields!.add('obra.plObra_intervencions'); */ obj
                  .plObra_intervencions =
              obj.plObra_intervencions ??
                  await obj.getObra_intervencions()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Obra) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnObra.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnObra.update(this);
    }

    return id;
  }

  /// Saves the (Obra) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnObra.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnObra.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Obra> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Obra> obras) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in obras) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnObra.rawInsert(
          'INSERT OR REPLACE INTO obra (id, nombreRepresentanteOSC, dateCreated)  VALUES (?,?,?)',
          [
            id,
            nombreRepresentanteOSC,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Obra id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Obra id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Obra Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Obra>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Obra> obras) async {
    final results = await _mnObra.rawInsertAll(
        'INSERT OR REPLACE INTO obra (id, nombreRepresentanteOSC, dateCreated)  VALUES (?,?,?)',
        obras);
    return results;
  }

  /// Deletes Obra

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Obra invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await Certificado().select().obraId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await Visita().select().obraId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DocumentacionTecnica()
          .select()
          .obraId
          .equals(id)
          .and
          .update({'obraId': null});
    }
    if (!result.success) {
      return result;
    }
    {
      result = await Obra_intervencion()
          .select()
          .obraId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnObra
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnObra.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  ObraFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ObraFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ObraFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ObraFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion obra

// region ObraField
class ObraField extends SearchCriteria {
  ObraField(this.obraFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  ObraFilterBuilder obraFB;

  ObraField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ObraFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    obraFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obraFB.parameters, param, SqlSyntax.EQuals,
            obraFB._addedBlocks)
        : setCriteria(pValue, obraFB.parameters, param, SqlSyntax.NotEQuals,
            obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    obraFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obraFB.parameters, param, SqlSyntax.EQualsOrNull,
            obraFB._addedBlocks)
        : setCriteria(pValue, obraFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder isNull() {
    obraFB._addedBlocks = setCriteria(
        0,
        obraFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      obraFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          obraFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obraFB._addedBlocks);
      _waitingNot = '';
      obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
          obraFB._addedBlocks.retVal;
    }
    return obraFB;
  }

  ObraFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      obraFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          obraFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obraFB._addedBlocks);
      _waitingNot = '';
      obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
          obraFB._addedBlocks.retVal;
      obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
          obraFB._addedBlocks.retVal;
    }
    return obraFB;
  }

  ObraFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      obraFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          obraFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obraFB._addedBlocks);
      _waitingNot = '';
      obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
          obraFB._addedBlocks.retVal;
    }
    return obraFB;
  }

  ObraFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      obraFB._addedBlocks = setCriteria(
          pFirst,
          obraFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obraFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        obraFB._addedBlocks = setCriteria(pFirst, obraFB.parameters, param,
            SqlSyntax.LessThan, obraFB._addedBlocks);
      } else {
        obraFB._addedBlocks = setCriteria(pFirst, obraFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, obraFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        obraFB._addedBlocks = setCriteria(pLast, obraFB.parameters, param,
            SqlSyntax.GreaterThan, obraFB._addedBlocks);
      } else {
        obraFB._addedBlocks = setCriteria(pLast, obraFB.parameters, param,
            SqlSyntax.LessThanOrEquals, obraFB._addedBlocks);
      }
    }
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    obraFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obraFB.parameters, param, SqlSyntax.GreaterThan,
            obraFB._addedBlocks)
        : setCriteria(pValue, obraFB.parameters, param,
            SqlSyntax.LessThanOrEquals, obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    obraFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obraFB.parameters, param, SqlSyntax.LessThan,
            obraFB._addedBlocks)
        : setCriteria(pValue, obraFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    obraFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obraFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, obraFB._addedBlocks)
        : setCriteria(pValue, obraFB.parameters, param, SqlSyntax.LessThan,
            obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    obraFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obraFB.parameters, param,
            SqlSyntax.LessThanOrEquals, obraFB._addedBlocks)
        : setCriteria(pValue, obraFB.parameters, param, SqlSyntax.GreaterThan,
            obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }

  ObraFilterBuilder inValues(dynamic pValue) {
    obraFB._addedBlocks = setCriteria(
        pValue,
        obraFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        obraFB._addedBlocks);
    _waitingNot = '';
    obraFB._addedBlocks.needEndBlock![obraFB._blockIndex] =
        obraFB._addedBlocks.retVal;
    return obraFB;
  }
}
// endregion ObraField

// region ObraFilterBuilder
class ObraFilterBuilder extends SearchCriteria {
  ObraFilterBuilder(Obra obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Obra? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  ObraFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ObraFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ObraFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ObraFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ObraFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ObraFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ObraFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ObraFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ObraFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ObraFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ObraFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ObraField setField(ObraField? field, String colName, DbType dbtype) {
    return ObraField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  ObraField? _id;
  ObraField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  ObraField? _nombreRepresentanteOSC;
  ObraField get nombreRepresentanteOSC {
    return _nombreRepresentanteOSC = setField(
        _nombreRepresentanteOSC, 'nombreRepresentanteOSC', DbType.text);
  }

  ObraField? _dateCreated;
  ObraField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Obra._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Obra> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Certificado) according to DeleteRule.CASCADE
    final idListCertificadoBYobraId = toListPrimaryKeySQL(false);
    final resCertificadoBYobraId = await Certificado()
        .select()
        .where('obraId IN (${idListCertificadoBYobraId['sql']})',
            parameterValue: idListCertificadoBYobraId['args'])
        .delete(hardDelete);
    if (!resCertificadoBYobraId.success) {
      return resCertificadoBYobraId;
    }
// Delete sub records where in (Visita) according to DeleteRule.CASCADE
    final idListVisitaBYobraId = toListPrimaryKeySQL(false);
    final resVisitaBYobraId = await Visita()
        .select()
        .where('obraId IN (${idListVisitaBYobraId['sql']})',
            parameterValue: idListVisitaBYobraId['args'])
        .delete(hardDelete);
    if (!resVisitaBYobraId.success) {
      return resVisitaBYobraId;
    }
// UPDATE sub records where in (DocumentacionTecnica) according to DeleteRule.SET_NULL
    final idListDocumentacionTecnicaBYobraId = toListPrimaryKeySQL(false);
    final resDocumentacionTecnicaBYobraId = await DocumentacionTecnica()
        .select()
        .where('obraId IN (${idListDocumentacionTecnicaBYobraId['sql']})',
            parameterValue: idListDocumentacionTecnicaBYobraId['args'])
        .update({'obraId': null});
    if (!resDocumentacionTecnicaBYobraId.success) {
      return resDocumentacionTecnicaBYobraId;
    }
// Delete sub records where in (Obra_intervencion) according to DeleteRule.CASCADE
    final idListObra_intervencionBYobraId = toListPrimaryKeySQL(false);
    final resObra_intervencionBYobraId = await Obra_intervencion()
        .select()
        .where('obraId IN (${idListObra_intervencionBYobraId['sql']})',
            parameterValue: idListObra_intervencionBYobraId['args'])
        .delete(hardDelete);
    if (!resObra_intervencionBYobraId.success) {
      return resObra_intervencionBYobraId;
    }

    if (Obra._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnObra.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnObra.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from obra ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnObra.updateBatch(qparams, values);
  }

  /// This method always returns [Obra] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Obra?
  Future<Obra?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnObra.toList(qparams);
    final data = await objFuture;
    Obra? obj;
    if (data.isNotEmpty) {
      obj = Obra.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plCertificados') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCertificados'))) {
          /*_loadedfields!.add('obra.plCertificados'); */ obj.plCertificados =
              obj.plCertificados ??
                  await obj.getCertificados()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVisitas'))) {
          /*_loadedfields!.add('obra.plVisitas'); */ obj.plVisitas =
              obj.plVisitas ??
                  await obj.getVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plDocumentacionTecnicas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDocumentacionTecnicas'))) {
          /*_loadedfields!.add('obra.plDocumentacionTecnicas'); */ obj
                  .plDocumentacionTecnicas =
              obj.plDocumentacionTecnicas ??
                  await obj.getDocumentacionTecnicas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plObra_intervencions') && */ (preloadFields ==
                null ||
            preloadFields.contains('plObra_intervencions'))) {
          /*_loadedfields!.add('obra.plObra_intervencions'); */ obj
                  .plObra_intervencions =
              obj.plObra_intervencions ??
                  await obj.getObra_intervencions()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Obra]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Obra?
  Future<Obra> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Obra();
  }

  /// This method returns int. [Obra]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? obraCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final obrasFuture = await _obj!._mnObra.toList(qparams);
    final int count = obrasFuture[0]['CNT'] as int;
    if (obraCount != null) {
      obraCount(count);
    }
    return count;
  }

  /// This method returns List<Obra> [Obra]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Obra>
  Future<List<Obra>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Obra> obrasData = await Obra.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return obrasData;
  }

  /// This method returns Json String [Obra]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Obra]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Obra]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnObra.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Obra>>
  Future<List<DropdownMenuItem<Obra>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Obra>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final obrasFuture = _obj!._mnObra.toList(qparams);

    final data = await obrasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Obra>> items = []..add(DropdownMenuItem(
        value: Obra(),
        child: Text('Select Obra'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Obra.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final obrasFuture = _obj!._mnObra.toList(qparams);

    final data = await obrasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Obra'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Obra]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM obra WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnObra.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Obra]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnObra.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Obra.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnObra.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ObraFilterBuilder

// region ObraFields
class ObraFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fNombreRepresentanteOSC;
  static TableField get nombreRepresentanteOSC {
    return _fNombreRepresentanteOSC = _fNombreRepresentanteOSC ??
        SqlSyntax.setField(
            _fNombreRepresentanteOSC, 'nombreRepresentanteOSC', DbType.text);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }
}
// endregion ObraFields

//region ObraManager
class ObraManager extends SqfEntityProvider {
  ObraManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'obra';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ObraManager
// region Vivienda
class Vivienda extends TableBase {
  Vivienda(
      {this.id,
      this.aliasRenabap,
      this.viviendaId,
      this.metrosCuadrados,
      this.ambientes,
      this.directoACalle,
      this.servicioCloacas,
      this.servicioLuz,
      this.servicioAgua,
      this.servicioGas,
      this.servicioInternet,
      this.reubicados,
      this.titular,
      this.contactoJefeHogar,
      this.contactoReferencia,
      this.jefeHogarNombre,
      this.cantHabitantes,
      this.habitantesAdultos,
      this.habitantesMenores,
      this.habitantesMayores,
      this.duenosVivienda,
      this.preguntasPgas,
      this.cuestionarioHabitabilidad,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Vivienda.withFields(
      this.id,
      this.aliasRenabap,
      this.viviendaId,
      this.metrosCuadrados,
      this.ambientes,
      this.directoACalle,
      this.servicioCloacas,
      this.servicioLuz,
      this.servicioAgua,
      this.servicioGas,
      this.servicioInternet,
      this.reubicados,
      this.titular,
      this.contactoJefeHogar,
      this.contactoReferencia,
      this.jefeHogarNombre,
      this.cantHabitantes,
      this.habitantesAdultos,
      this.habitantesMenores,
      this.habitantesMayores,
      this.duenosVivienda,
      this.preguntasPgas,
      this.cuestionarioHabitabilidad,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  Vivienda.withId(
      this.id,
      this.aliasRenabap,
      this.viviendaId,
      this.metrosCuadrados,
      this.ambientes,
      this.directoACalle,
      this.servicioCloacas,
      this.servicioLuz,
      this.servicioAgua,
      this.servicioGas,
      this.servicioInternet,
      this.reubicados,
      this.titular,
      this.contactoJefeHogar,
      this.contactoReferencia,
      this.jefeHogarNombre,
      this.cantHabitantes,
      this.habitantesAdultos,
      this.habitantesMenores,
      this.habitantesMayores,
      this.duenosVivienda,
      this.preguntasPgas,
      this.cuestionarioHabitabilidad,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Vivienda.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['aliasRenabap'] != null) {
      aliasRenabap = o['aliasRenabap'].toString();
    }
    if (o['viviendaId'] != null) {
      viviendaId = o['viviendaId'].toString();
    }
    if (o['metrosCuadrados'] != null) {
      metrosCuadrados = int.tryParse(o['metrosCuadrados'].toString());
    }
    if (o['ambientes'] != null) {
      ambientes = int.tryParse(o['ambientes'].toString());
    }
    if (o['directoACalle'] != null) {
      directoACalle = o['directoACalle'].toString() == '1' ||
          o['directoACalle'].toString() == 'true';
    }
    if (o['servicioCloacas'] != null) {
      servicioCloacas = o['servicioCloacas'].toString() == '1' ||
          o['servicioCloacas'].toString() == 'true';
    }
    if (o['servicioLuz'] != null) {
      servicioLuz = o['servicioLuz'].toString() == '1' ||
          o['servicioLuz'].toString() == 'true';
    }
    if (o['servicioAgua'] != null) {
      servicioAgua = o['servicioAgua'].toString() == '1' ||
          o['servicioAgua'].toString() == 'true';
    }
    if (o['servicioGas'] != null) {
      servicioGas = o['servicioGas'].toString() == '1' ||
          o['servicioGas'].toString() == 'true';
    }
    if (o['servicioInternet'] != null) {
      servicioInternet = o['servicioInternet'].toString() == '1' ||
          o['servicioInternet'].toString() == 'true';
    }
    if (o['reubicados'] != null) {
      reubicados = o['reubicados'].toString() == '1' ||
          o['reubicados'].toString() == 'true';
    }
    if (o['titular'] != null) {
      titular = o['titular'].toString();
    }
    if (o['contactoJefeHogar'] != null) {
      contactoJefeHogar = o['contactoJefeHogar'].toString();
    }
    if (o['contactoReferencia'] != null) {
      contactoReferencia = o['contactoReferencia'].toString();
    }
    if (o['jefeHogarNombre'] != null) {
      jefeHogarNombre = o['jefeHogarNombre'].toString();
    }
    if (o['cantHabitantes'] != null) {
      cantHabitantes = int.tryParse(o['cantHabitantes'].toString());
    }
    if (o['habitantesAdultos'] != null) {
      habitantesAdultos = int.tryParse(o['habitantesAdultos'].toString());
    }
    if (o['habitantesMenores'] != null) {
      habitantesMenores = int.tryParse(o['habitantesMenores'].toString());
    }
    if (o['habitantesMayores'] != null) {
      habitantesMayores = int.tryParse(o['habitantesMayores'].toString());
    }
    if (o['duenosVivienda'] != null) {
      duenosVivienda = o['duenosVivienda'].toString() == '1' ||
          o['duenosVivienda'].toString() == 'true';
    }
    if (o['preguntasPgas'] != null) {
      preguntasPgas = o['preguntasPgas'].toString() == '1' ||
          o['preguntasPgas'].toString() == 'true';
    }
    if (o['cuestionarioHabitabilidad'] != null) {
      cuestionarioHabitabilidad =
          o['cuestionarioHabitabilidad'].toString() == '1' ||
              o['cuestionarioHabitabilidad'].toString() == 'true';
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    isSaved = true;
  }
  // FIELDS (Vivienda)
  int? id;
  String? aliasRenabap;
  String? viviendaId;
  int? metrosCuadrados;
  int? ambientes;
  bool? directoACalle;
  bool? servicioCloacas;
  bool? servicioLuz;
  bool? servicioAgua;
  bool? servicioGas;
  bool? servicioInternet;
  bool? reubicados;
  String? titular;
  String? contactoJefeHogar;
  String? contactoReferencia;
  String? jefeHogarNombre;
  int? cantHabitantes;
  int? habitantesAdultos;
  int? habitantesMenores;
  int? habitantesMayores;
  bool? duenosVivienda;
  bool? preguntasPgas;
  bool? cuestionarioHabitabilidad;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Vivienda)

// COLLECTIONS & VIRTUALS (Vivienda)
  Ubicacion? _ubicacion;
  Ubicacion get ubicacion {
    return _ubicacion = _ubicacion ?? Ubicacion();
  }

  set ubicacion(Ubicacion ubicacion) {
    _ubicacion = ubicacion;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRespuestaVisitas', 'plField2'..]) or so on..
  List<RespuestaVisita>? plRespuestaVisitas;

  /// get RespuestaVisita(s) filtered by id=viviendaId
  RespuestaVisitaFilterBuilder? getRespuestaVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return RespuestaVisita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .viviendaId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFotoViviendas', 'plField2'..]) or so on..
  List<FotoVivienda>? plFotoViviendas;

  /// get FotoVivienda(s) filtered by id=viviendaId
  FotoViviendaFilterBuilder? getFotoViviendas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return FotoVivienda()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .viviendaId
        .equals(id)
        .and;
  }

  DocumentacionTecnica? _documentaciontecnica;
  DocumentacionTecnica get documentaciontecnica {
    return _documentaciontecnica =
        _documentaciontecnica ?? DocumentacionTecnica();
  }

  set documentaciontecnica(DocumentacionTecnica documentaciontecnica) {
    _documentaciontecnica = documentaciontecnica;
  }

// END COLLECTIONS & VIRTUALS (Vivienda)

  static const bool _softDeleteActivated = true;
  ViviendaManager? __mnVivienda;

  ViviendaManager get _mnVivienda {
    return __mnVivienda = __mnVivienda ?? ViviendaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['aliasRenabap'] = aliasRenabap;
    map['viviendaId'] = viviendaId;
    map['metrosCuadrados'] = metrosCuadrados;
    map['ambientes'] = ambientes;
    if (directoACalle != null) {
      map['directoACalle'] =
          forQuery ? (directoACalle! ? 1 : 0) : directoACalle;
    } else {
      map['directoACalle'] = null;
    }
    if (servicioCloacas != null) {
      map['servicioCloacas'] =
          forQuery ? (servicioCloacas! ? 1 : 0) : servicioCloacas;
    } else {
      map['servicioCloacas'] = null;
    }
    if (servicioLuz != null) {
      map['servicioLuz'] = forQuery ? (servicioLuz! ? 1 : 0) : servicioLuz;
    } else {
      map['servicioLuz'] = null;
    }
    if (servicioAgua != null) {
      map['servicioAgua'] = forQuery ? (servicioAgua! ? 1 : 0) : servicioAgua;
    } else {
      map['servicioAgua'] = null;
    }
    if (servicioGas != null) {
      map['servicioGas'] = forQuery ? (servicioGas! ? 1 : 0) : servicioGas;
    } else {
      map['servicioGas'] = null;
    }
    if (servicioInternet != null) {
      map['servicioInternet'] =
          forQuery ? (servicioInternet! ? 1 : 0) : servicioInternet;
    } else {
      map['servicioInternet'] = null;
    }
    if (reubicados != null) {
      map['reubicados'] = forQuery ? (reubicados! ? 1 : 0) : reubicados;
    } else {
      map['reubicados'] = null;
    }
    map['titular'] = titular;
    map['contactoJefeHogar'] = contactoJefeHogar;
    map['contactoReferencia'] = contactoReferencia;
    map['jefeHogarNombre'] = jefeHogarNombre;
    map['cantHabitantes'] = cantHabitantes;
    map['habitantesAdultos'] = habitantesAdultos;
    map['habitantesMenores'] = habitantesMenores;
    map['habitantesMayores'] = habitantesMayores;
    if (duenosVivienda != null) {
      map['duenosVivienda'] =
          forQuery ? (duenosVivienda! ? 1 : 0) : duenosVivienda;
    } else {
      map['duenosVivienda'] = null;
    }
    if (preguntasPgas != null) {
      map['preguntasPgas'] =
          forQuery ? (preguntasPgas! ? 1 : 0) : preguntasPgas;
    } else {
      map['preguntasPgas'] = null;
    }
    if (cuestionarioHabitabilidad != null) {
      map['cuestionarioHabitabilidad'] = forQuery
          ? (cuestionarioHabitabilidad! ? 1 : 0)
          : cuestionarioHabitabilidad;
    } else {
      map['cuestionarioHabitabilidad'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['aliasRenabap'] = aliasRenabap;
    map['viviendaId'] = viviendaId;
    map['metrosCuadrados'] = metrosCuadrados;
    map['ambientes'] = ambientes;
    if (directoACalle != null) {
      map['directoACalle'] =
          forQuery ? (directoACalle! ? 1 : 0) : directoACalle;
    } else {
      map['directoACalle'] = null;
    }
    if (servicioCloacas != null) {
      map['servicioCloacas'] =
          forQuery ? (servicioCloacas! ? 1 : 0) : servicioCloacas;
    } else {
      map['servicioCloacas'] = null;
    }
    if (servicioLuz != null) {
      map['servicioLuz'] = forQuery ? (servicioLuz! ? 1 : 0) : servicioLuz;
    } else {
      map['servicioLuz'] = null;
    }
    if (servicioAgua != null) {
      map['servicioAgua'] = forQuery ? (servicioAgua! ? 1 : 0) : servicioAgua;
    } else {
      map['servicioAgua'] = null;
    }
    if (servicioGas != null) {
      map['servicioGas'] = forQuery ? (servicioGas! ? 1 : 0) : servicioGas;
    } else {
      map['servicioGas'] = null;
    }
    if (servicioInternet != null) {
      map['servicioInternet'] =
          forQuery ? (servicioInternet! ? 1 : 0) : servicioInternet;
    } else {
      map['servicioInternet'] = null;
    }
    if (reubicados != null) {
      map['reubicados'] = forQuery ? (reubicados! ? 1 : 0) : reubicados;
    } else {
      map['reubicados'] = null;
    }
    map['titular'] = titular;
    map['contactoJefeHogar'] = contactoJefeHogar;
    map['contactoReferencia'] = contactoReferencia;
    map['jefeHogarNombre'] = jefeHogarNombre;
    map['cantHabitantes'] = cantHabitantes;
    map['habitantesAdultos'] = habitantesAdultos;
    map['habitantesMenores'] = habitantesMenores;
    map['habitantesMayores'] = habitantesMayores;
    if (duenosVivienda != null) {
      map['duenosVivienda'] =
          forQuery ? (duenosVivienda! ? 1 : 0) : duenosVivienda;
    } else {
      map['duenosVivienda'] = null;
    }
    if (preguntasPgas != null) {
      map['preguntasPgas'] =
          forQuery ? (preguntasPgas! ? 1 : 0) : preguntasPgas;
    } else {
      map['preguntasPgas'] = null;
    }
    if (cuestionarioHabitabilidad != null) {
      map['cuestionarioHabitabilidad'] = forQuery
          ? (cuestionarioHabitabilidad! ? 1 : 0)
          : cuestionarioHabitabilidad;
    } else {
      map['cuestionarioHabitabilidad'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Vivienda)
    if (!forQuery) {
      map['ubicacion'] = await ubicacion.toMapWithChildren();
    }
    if (!forQuery) {
      map['RespuestaVisitas'] = await getRespuestaVisitas()!.toMapList();
    }
    if (!forQuery) {
      map['FotoViviendas'] = await getFotoViviendas()!.toMapList();
    }
    if (!forQuery) {
      map['documentaciontecnica'] =
          await documentaciontecnica.toMapWithChildren();
    }
// END COLLECTIONS (Vivienda)

    return map;
  }

  /// This method returns Json String [Vivienda]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Vivienda]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      aliasRenabap,
      viviendaId,
      metrosCuadrados,
      ambientes,
      directoACalle,
      servicioCloacas,
      servicioLuz,
      servicioAgua,
      servicioGas,
      servicioInternet,
      reubicados,
      titular,
      contactoJefeHogar,
      contactoReferencia,
      jefeHogarNombre,
      cantHabitantes,
      habitantesAdultos,
      habitantesMenores,
      habitantesMayores,
      duenosVivienda,
      preguntasPgas,
      cuestionarioHabitabilidad,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      aliasRenabap,
      viviendaId,
      metrosCuadrados,
      ambientes,
      directoACalle,
      servicioCloacas,
      servicioLuz,
      servicioAgua,
      servicioGas,
      servicioInternet,
      reubicados,
      titular,
      contactoJefeHogar,
      contactoReferencia,
      jefeHogarNombre,
      cantHabitantes,
      habitantesAdultos,
      habitantesMenores,
      habitantesMayores,
      duenosVivienda,
      preguntasPgas,
      cuestionarioHabitabilidad,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Vivienda>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Vivienda.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Vivienda>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Vivienda>[];
    try {
      objList = list
          .map((vivienda) => Vivienda.fromMap(vivienda as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Vivienda.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Vivienda>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Vivienda> objList = <Vivienda>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Vivienda.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

//      RELATIONS OneToOne (Vivienda)
      obj
        .._ubicacion = await Ubicacion().select()._id.equals(obj.id).toSingle()
        .._documentaciontecnica = await DocumentacionTecnica()
            .select()
            ._id
            .equals(obj.id)
            .toSingle(); //      END RELATIONS OneToOne (Vivienda)

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('vivienda.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('vivienda.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('vivienda.plFotoViviendas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoViviendas'))) {
          /*_loadedfields!.add('vivienda.plFotoViviendas'); */ obj
                  .plFotoViviendas =
              obj.plFotoViviendas ??
                  await obj.getFotoViviendas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Vivienda by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Vivienda] if exist, otherwise returns null
  Future<Vivienda?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Vivienda? obj;
    final data = await _mnVivienda.getById([id]);
    if (data.length != 0) {
      obj = Vivienda.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

//      RELATIONS OneToOne (Vivienda)
      obj
        .._ubicacion = await Ubicacion().select()._id.equals(obj.id).toSingle()
        .._documentaciontecnica = await DocumentacionTecnica()
            .select()
            ._id
            .equals(obj.id)
            .toSingle(); //      END RELATIONS OneToOne (Vivienda)

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('vivienda.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('vivienda.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('vivienda.plFotoViviendas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoViviendas'))) {
          /*_loadedfields!.add('vivienda.plFotoViviendas'); */ obj
                  .plFotoViviendas =
              obj.plFotoViviendas ??
                  await obj.getFotoViviendas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Vivienda) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnVivienda.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVivienda.update(this);
    }

// save() OneToOne relations (Vivienda)
    _ubicacion?._id = id;
    await _ubicacion?._save();
    _documentaciontecnica?._id = id;
    await _documentaciontecnica?._save();
// END save() OneToOne relations (Vivienda)

    return id;
  }

  /// Saves the (Vivienda) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnVivienda.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVivienda.updateOrThrow(this);
    }

// save() OneToOne relations (Vivienda)
    _ubicacion?._id = id;
    await _ubicacion?._save();
    _documentaciontecnica?._id = id;
    await _documentaciontecnica?._save();
// END save() OneToOne relations (Vivienda)

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Vivienda> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Vivienda> viviendas) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in viviendas) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVivienda.rawInsert(
          'INSERT OR REPLACE INTO vivienda (id, aliasRenabap, viviendaId, metrosCuadrados, ambientes, directoACalle, servicioCloacas, servicioLuz, servicioAgua, servicioGas, servicioInternet, reubicados, titular, contactoJefeHogar, contactoReferencia, jefeHogarNombre, cantHabitantes, habitantesAdultos, habitantesMenores, habitantesMayores, duenosVivienda, preguntasPgas, cuestionarioHabitabilidad, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            aliasRenabap,
            viviendaId,
            metrosCuadrados,
            ambientes,
            directoACalle,
            servicioCloacas,
            servicioLuz,
            servicioAgua,
            servicioGas,
            servicioInternet,
            reubicados,
            titular,
            contactoJefeHogar,
            contactoReferencia,
            jefeHogarNombre,
            cantHabitantes,
            habitantesAdultos,
            habitantesMenores,
            habitantesMayores,
            duenosVivienda,
            preguntasPgas,
            cuestionarioHabitabilidad,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Vivienda id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Vivienda id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Vivienda Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Vivienda>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Vivienda> viviendas) async {
    final results = await _mnVivienda.rawInsertAll(
        'INSERT OR REPLACE INTO vivienda (id, aliasRenabap, viviendaId, metrosCuadrados, ambientes, directoACalle, servicioCloacas, servicioLuz, servicioAgua, servicioGas, servicioInternet, reubicados, titular, contactoJefeHogar, contactoReferencia, jefeHogarNombre, cantHabitantes, habitantesAdultos, habitantesMenores, habitantesMayores, duenosVivienda, preguntasPgas, cuestionarioHabitabilidad, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        viviendas);
    return results;
  }

  /// Deletes Vivienda

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Vivienda invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Ubicacion().select()._id.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await RespuestaVisita()
          .select()
          .viviendaId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await FotoVivienda()
          .select()
          .viviendaId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DocumentacionTecnica()
          .select()
          ._id
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnVivienda
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnVivienda.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Vivienda>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Vivienda invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await RespuestaVisita()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .viviendaId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await FotoVivienda()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .viviendaId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await DocumentacionTecnica()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          ._id
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnVivienda.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  ViviendaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ViviendaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ViviendaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ViviendaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    directoACalle = directoACalle ?? false;
    servicioCloacas = servicioCloacas ?? false;
    servicioLuz = servicioLuz ?? false;
    servicioAgua = servicioAgua ?? false;
    servicioGas = servicioGas ?? false;
    servicioInternet = servicioInternet ?? false;
    reubicados = reubicados ?? false;
    duenosVivienda = duenosVivienda ?? false;
    preguntasPgas = preguntasPgas ?? false;
    cuestionarioHabitabilidad = cuestionarioHabitabilidad ?? false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vivienda

// region ViviendaField
class ViviendaField extends SearchCriteria {
  ViviendaField(this.viviendaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  ViviendaFilterBuilder viviendaFB;

  ViviendaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ViviendaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    viviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, viviendaFB.parameters, param, SqlSyntax.EQuals,
            viviendaFB._addedBlocks)
        : setCriteria(pValue, viviendaFB.parameters, param, SqlSyntax.NotEQuals,
            viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    viviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.EQualsOrNull, viviendaFB._addedBlocks)
        : setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder isNull() {
    viviendaFB._addedBlocks = setCriteria(
        0,
        viviendaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      viviendaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          viviendaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          viviendaFB._addedBlocks);
      _waitingNot = '';
      viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
          viviendaFB._addedBlocks.retVal;
    }
    return viviendaFB;
  }

  ViviendaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      viviendaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          viviendaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          viviendaFB._addedBlocks);
      _waitingNot = '';
      viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
          viviendaFB._addedBlocks.retVal;
      viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
          viviendaFB._addedBlocks.retVal;
    }
    return viviendaFB;
  }

  ViviendaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      viviendaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          viviendaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          viviendaFB._addedBlocks);
      _waitingNot = '';
      viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
          viviendaFB._addedBlocks.retVal;
    }
    return viviendaFB;
  }

  ViviendaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      viviendaFB._addedBlocks = setCriteria(
          pFirst,
          viviendaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          viviendaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        viviendaFB._addedBlocks = setCriteria(pFirst, viviendaFB.parameters,
            param, SqlSyntax.LessThan, viviendaFB._addedBlocks);
      } else {
        viviendaFB._addedBlocks = setCriteria(pFirst, viviendaFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, viviendaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        viviendaFB._addedBlocks = setCriteria(pLast, viviendaFB.parameters,
            param, SqlSyntax.GreaterThan, viviendaFB._addedBlocks);
      } else {
        viviendaFB._addedBlocks = setCriteria(pLast, viviendaFB.parameters,
            param, SqlSyntax.LessThanOrEquals, viviendaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    viviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.GreaterThan, viviendaFB._addedBlocks)
        : setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    viviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, viviendaFB.parameters, param, SqlSyntax.LessThan,
            viviendaFB._addedBlocks)
        : setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    viviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, viviendaFB._addedBlocks)
        : setCriteria(pValue, viviendaFB.parameters, param, SqlSyntax.LessThan,
            viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    viviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, viviendaFB._addedBlocks)
        : setCriteria(pValue, viviendaFB.parameters, param,
            SqlSyntax.GreaterThan, viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }

  ViviendaFilterBuilder inValues(dynamic pValue) {
    viviendaFB._addedBlocks = setCriteria(
        pValue,
        viviendaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        viviendaFB._addedBlocks);
    _waitingNot = '';
    viviendaFB._addedBlocks.needEndBlock![viviendaFB._blockIndex] =
        viviendaFB._addedBlocks.retVal;
    return viviendaFB;
  }
}
// endregion ViviendaField

// region ViviendaFilterBuilder
class ViviendaFilterBuilder extends SearchCriteria {
  ViviendaFilterBuilder(Vivienda obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Vivienda? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  ViviendaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ViviendaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ViviendaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ViviendaFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ViviendaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ViviendaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ViviendaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ViviendaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ViviendaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ViviendaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ViviendaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ViviendaField setField(ViviendaField? field, String colName, DbType dbtype) {
    return ViviendaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  ViviendaField? _id;
  ViviendaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  ViviendaField? _aliasRenabap;
  ViviendaField get aliasRenabap {
    return _aliasRenabap = setField(_aliasRenabap, 'aliasRenabap', DbType.text);
  }

  ViviendaField? _viviendaId;
  ViviendaField get viviendaId {
    return _viviendaId = setField(_viviendaId, 'viviendaId', DbType.text);
  }

  ViviendaField? _metrosCuadrados;
  ViviendaField get metrosCuadrados {
    return _metrosCuadrados =
        setField(_metrosCuadrados, 'metrosCuadrados', DbType.integer);
  }

  ViviendaField? _ambientes;
  ViviendaField get ambientes {
    return _ambientes = setField(_ambientes, 'ambientes', DbType.integer);
  }

  ViviendaField? _directoACalle;
  ViviendaField get directoACalle {
    return _directoACalle =
        setField(_directoACalle, 'directoACalle', DbType.bool);
  }

  ViviendaField? _servicioCloacas;
  ViviendaField get servicioCloacas {
    return _servicioCloacas =
        setField(_servicioCloacas, 'servicioCloacas', DbType.bool);
  }

  ViviendaField? _servicioLuz;
  ViviendaField get servicioLuz {
    return _servicioLuz = setField(_servicioLuz, 'servicioLuz', DbType.bool);
  }

  ViviendaField? _servicioAgua;
  ViviendaField get servicioAgua {
    return _servicioAgua = setField(_servicioAgua, 'servicioAgua', DbType.bool);
  }

  ViviendaField? _servicioGas;
  ViviendaField get servicioGas {
    return _servicioGas = setField(_servicioGas, 'servicioGas', DbType.bool);
  }

  ViviendaField? _servicioInternet;
  ViviendaField get servicioInternet {
    return _servicioInternet =
        setField(_servicioInternet, 'servicioInternet', DbType.bool);
  }

  ViviendaField? _reubicados;
  ViviendaField get reubicados {
    return _reubicados = setField(_reubicados, 'reubicados', DbType.bool);
  }

  ViviendaField? _titular;
  ViviendaField get titular {
    return _titular = setField(_titular, 'titular', DbType.text);
  }

  ViviendaField? _contactoJefeHogar;
  ViviendaField get contactoJefeHogar {
    return _contactoJefeHogar =
        setField(_contactoJefeHogar, 'contactoJefeHogar', DbType.text);
  }

  ViviendaField? _contactoReferencia;
  ViviendaField get contactoReferencia {
    return _contactoReferencia =
        setField(_contactoReferencia, 'contactoReferencia', DbType.text);
  }

  ViviendaField? _jefeHogarNombre;
  ViviendaField get jefeHogarNombre {
    return _jefeHogarNombre =
        setField(_jefeHogarNombre, 'jefeHogarNombre', DbType.text);
  }

  ViviendaField? _cantHabitantes;
  ViviendaField get cantHabitantes {
    return _cantHabitantes =
        setField(_cantHabitantes, 'cantHabitantes', DbType.integer);
  }

  ViviendaField? _habitantesAdultos;
  ViviendaField get habitantesAdultos {
    return _habitantesAdultos =
        setField(_habitantesAdultos, 'habitantesAdultos', DbType.integer);
  }

  ViviendaField? _habitantesMenores;
  ViviendaField get habitantesMenores {
    return _habitantesMenores =
        setField(_habitantesMenores, 'habitantesMenores', DbType.integer);
  }

  ViviendaField? _habitantesMayores;
  ViviendaField get habitantesMayores {
    return _habitantesMayores =
        setField(_habitantesMayores, 'habitantesMayores', DbType.integer);
  }

  ViviendaField? _duenosVivienda;
  ViviendaField get duenosVivienda {
    return _duenosVivienda =
        setField(_duenosVivienda, 'duenosVivienda', DbType.bool);
  }

  ViviendaField? _preguntasPgas;
  ViviendaField get preguntasPgas {
    return _preguntasPgas =
        setField(_preguntasPgas, 'preguntasPgas', DbType.bool);
  }

  ViviendaField? _cuestionarioHabitabilidad;
  ViviendaField get cuestionarioHabitabilidad {
    return _cuestionarioHabitabilidad = setField(
        _cuestionarioHabitabilidad, 'cuestionarioHabitabilidad', DbType.bool);
  }

  ViviendaField? _dateCreated;
  ViviendaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  ViviendaField? _isDeleted;
  ViviendaField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Vivienda._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Vivienda> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Ubicacion) according to DeleteRule.CASCADE
    final idListUbicacionBY_id = toListPrimaryKeySQL(false);
    final resUbicacionBY_id = await Ubicacion()
        .select()
        .where('_id IN (${idListUbicacionBY_id['sql']})',
            parameterValue: idListUbicacionBY_id['args'])
        .delete(hardDelete);
    if (!resUbicacionBY_id.success) {
      return resUbicacionBY_id;
    }
// Delete sub records where in (RespuestaVisita) according to DeleteRule.CASCADE
    final idListRespuestaVisitaBYviviendaId = toListPrimaryKeySQL(false);
    final resRespuestaVisitaBYviviendaId = await RespuestaVisita()
        .select()
        .where('viviendaId IN (${idListRespuestaVisitaBYviviendaId['sql']})',
            parameterValue: idListRespuestaVisitaBYviviendaId['args'])
        .delete(hardDelete);
    if (!resRespuestaVisitaBYviviendaId.success) {
      return resRespuestaVisitaBYviviendaId;
    }
// Delete sub records where in (FotoVivienda) according to DeleteRule.CASCADE
    final idListFotoViviendaBYviviendaId = toListPrimaryKeySQL(false);
    final resFotoViviendaBYviviendaId = await FotoVivienda()
        .select()
        .where('viviendaId IN (${idListFotoViviendaBYviviendaId['sql']})',
            parameterValue: idListFotoViviendaBYviviendaId['args'])
        .delete(hardDelete);
    if (!resFotoViviendaBYviviendaId.success) {
      return resFotoViviendaBYviviendaId;
    }
// Delete sub records where in (DocumentacionTecnica) according to DeleteRule.CASCADE
    final idListDocumentacionTecnicaBY_id = toListPrimaryKeySQL(false);
    final resDocumentacionTecnicaBY_id = await DocumentacionTecnica()
        .select()
        .where('_id IN (${idListDocumentacionTecnicaBY_id['sql']})',
            parameterValue: idListDocumentacionTecnicaBY_id['args'])
        .delete(hardDelete);
    if (!resDocumentacionTecnicaBY_id.success) {
      return resDocumentacionTecnicaBY_id;
    }

    if (Vivienda._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnVivienda.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnVivienda.delete(qparams);
    }
    return r;
  }

  /// Recover List<Vivienda> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover Vivienda bulk invoked');
    // Recover sub records where in (RespuestaVisita) according to DeleteRule.CASCADE
    final idListRespuestaVisitaBYviviendaId = toListPrimaryKeySQL(false);
    final resRespuestaVisitaBYviviendaId = await RespuestaVisita()
        .select()
        .where('viviendaId IN (${idListRespuestaVisitaBYviviendaId['sql']})',
            parameterValue: idListRespuestaVisitaBYviviendaId['args'])
        .update({'isDeleted': 0});
    if (!resRespuestaVisitaBYviviendaId.success) {
      return resRespuestaVisitaBYviviendaId;
    }
// Recover sub records where in (FotoVivienda) according to DeleteRule.CASCADE
    final idListFotoViviendaBYviviendaId = toListPrimaryKeySQL(false);
    final resFotoViviendaBYviviendaId = await FotoVivienda()
        .select()
        .where('viviendaId IN (${idListFotoViviendaBYviviendaId['sql']})',
            parameterValue: idListFotoViviendaBYviviendaId['args'])
        .update({'isDeleted': 0});
    if (!resFotoViviendaBYviviendaId.success) {
      return resFotoViviendaBYviviendaId;
    }
// Recover sub records where in (DocumentacionTecnica) according to DeleteRule.CASCADE
    final idListDocumentacionTecnicaBY_id = toListPrimaryKeySQL(false);
    final resDocumentacionTecnicaBY_id = await DocumentacionTecnica()
        .select()
        .where('_id IN (${idListDocumentacionTecnicaBY_id['sql']})',
            parameterValue: idListDocumentacionTecnicaBY_id['args'])
        .update({'isDeleted': 0});
    if (!resDocumentacionTecnicaBY_id.success) {
      return resDocumentacionTecnicaBY_id;
    }
    return _obj!._mnVivienda.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from vivienda ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnVivienda.updateBatch(qparams, values);
  }

  /// This method always returns [Vivienda] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Vivienda?
  Future<Vivienda?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnVivienda.toList(qparams);
    final data = await objFuture;
    Vivienda? obj;
    if (data.isNotEmpty) {
      obj = Vivienda.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

//      RELATIONS OneToOne (Vivienda)
      obj
        .._ubicacion = await Ubicacion().select()._id.equals(obj.id).toSingle()
        .._documentaciontecnica = await DocumentacionTecnica()
            .select()
            ._id
            .equals(obj.id)
            .toSingle(); //      END RELATIONS OneToOne (Vivienda)

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('vivienda.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('vivienda.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('vivienda.plFotoViviendas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoViviendas'))) {
          /*_loadedfields!.add('vivienda.plFotoViviendas'); */ obj
                  .plFotoViviendas =
              obj.plFotoViviendas ??
                  await obj.getFotoViviendas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Vivienda]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Vivienda?
  Future<Vivienda> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Vivienda();
  }

  /// This method returns int. [Vivienda]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? viviendaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final viviendasFuture = await _obj!._mnVivienda.toList(qparams);
    final int count = viviendasFuture[0]['CNT'] as int;
    if (viviendaCount != null) {
      viviendaCount(count);
    }
    return count;
  }

  /// This method returns List<Vivienda> [Vivienda]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Vivienda>
  Future<List<Vivienda>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Vivienda> viviendasData = await Vivienda.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return viviendasData;
  }

  /// This method returns Json String [Vivienda]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Vivienda]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Vivienda]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnVivienda.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Vivienda>>
  Future<List<DropdownMenuItem<Vivienda>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Vivienda>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final viviendasFuture = _obj!._mnVivienda.toList(qparams);

    final data = await viviendasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Vivienda>> items = []..add(DropdownMenuItem(
        value: Vivienda(),
        child: Text('Select Vivienda'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Vivienda.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final viviendasFuture = _obj!._mnVivienda.toList(qparams);

    final data = await viviendasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Vivienda'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Vivienda]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM vivienda WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnVivienda.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Vivienda]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnVivienda.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Vivienda.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnVivienda.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ViviendaFilterBuilder

// region ViviendaFields
class ViviendaFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fAliasRenabap;
  static TableField get aliasRenabap {
    return _fAliasRenabap = _fAliasRenabap ??
        SqlSyntax.setField(_fAliasRenabap, 'aliasRenabap', DbType.text);
  }

  static TableField? _fViviendaId;
  static TableField get viviendaId {
    return _fViviendaId = _fViviendaId ??
        SqlSyntax.setField(_fViviendaId, 'viviendaId', DbType.text);
  }

  static TableField? _fMetrosCuadrados;
  static TableField get metrosCuadrados {
    return _fMetrosCuadrados = _fMetrosCuadrados ??
        SqlSyntax.setField(
            _fMetrosCuadrados, 'metrosCuadrados', DbType.integer);
  }

  static TableField? _fAmbientes;
  static TableField get ambientes {
    return _fAmbientes = _fAmbientes ??
        SqlSyntax.setField(_fAmbientes, 'ambientes', DbType.integer);
  }

  static TableField? _fDirectoACalle;
  static TableField get directoACalle {
    return _fDirectoACalle = _fDirectoACalle ??
        SqlSyntax.setField(_fDirectoACalle, 'directoACalle', DbType.bool);
  }

  static TableField? _fServicioCloacas;
  static TableField get servicioCloacas {
    return _fServicioCloacas = _fServicioCloacas ??
        SqlSyntax.setField(_fServicioCloacas, 'servicioCloacas', DbType.bool);
  }

  static TableField? _fServicioLuz;
  static TableField get servicioLuz {
    return _fServicioLuz = _fServicioLuz ??
        SqlSyntax.setField(_fServicioLuz, 'servicioLuz', DbType.bool);
  }

  static TableField? _fServicioAgua;
  static TableField get servicioAgua {
    return _fServicioAgua = _fServicioAgua ??
        SqlSyntax.setField(_fServicioAgua, 'servicioAgua', DbType.bool);
  }

  static TableField? _fServicioGas;
  static TableField get servicioGas {
    return _fServicioGas = _fServicioGas ??
        SqlSyntax.setField(_fServicioGas, 'servicioGas', DbType.bool);
  }

  static TableField? _fServicioInternet;
  static TableField get servicioInternet {
    return _fServicioInternet = _fServicioInternet ??
        SqlSyntax.setField(_fServicioInternet, 'servicioInternet', DbType.bool);
  }

  static TableField? _fReubicados;
  static TableField get reubicados {
    return _fReubicados = _fReubicados ??
        SqlSyntax.setField(_fReubicados, 'reubicados', DbType.bool);
  }

  static TableField? _fTitular;
  static TableField get titular {
    return _fTitular =
        _fTitular ?? SqlSyntax.setField(_fTitular, 'titular', DbType.text);
  }

  static TableField? _fContactoJefeHogar;
  static TableField get contactoJefeHogar {
    return _fContactoJefeHogar = _fContactoJefeHogar ??
        SqlSyntax.setField(
            _fContactoJefeHogar, 'contactoJefeHogar', DbType.text);
  }

  static TableField? _fContactoReferencia;
  static TableField get contactoReferencia {
    return _fContactoReferencia = _fContactoReferencia ??
        SqlSyntax.setField(
            _fContactoReferencia, 'contactoReferencia', DbType.text);
  }

  static TableField? _fJefeHogarNombre;
  static TableField get jefeHogarNombre {
    return _fJefeHogarNombre = _fJefeHogarNombre ??
        SqlSyntax.setField(_fJefeHogarNombre, 'jefeHogarNombre', DbType.text);
  }

  static TableField? _fCantHabitantes;
  static TableField get cantHabitantes {
    return _fCantHabitantes = _fCantHabitantes ??
        SqlSyntax.setField(_fCantHabitantes, 'cantHabitantes', DbType.integer);
  }

  static TableField? _fHabitantesAdultos;
  static TableField get habitantesAdultos {
    return _fHabitantesAdultos = _fHabitantesAdultos ??
        SqlSyntax.setField(
            _fHabitantesAdultos, 'habitantesAdultos', DbType.integer);
  }

  static TableField? _fHabitantesMenores;
  static TableField get habitantesMenores {
    return _fHabitantesMenores = _fHabitantesMenores ??
        SqlSyntax.setField(
            _fHabitantesMenores, 'habitantesMenores', DbType.integer);
  }

  static TableField? _fHabitantesMayores;
  static TableField get habitantesMayores {
    return _fHabitantesMayores = _fHabitantesMayores ??
        SqlSyntax.setField(
            _fHabitantesMayores, 'habitantesMayores', DbType.integer);
  }

  static TableField? _fDuenosVivienda;
  static TableField get duenosVivienda {
    return _fDuenosVivienda = _fDuenosVivienda ??
        SqlSyntax.setField(_fDuenosVivienda, 'duenosVivienda', DbType.bool);
  }

  static TableField? _fPreguntasPgas;
  static TableField get preguntasPgas {
    return _fPreguntasPgas = _fPreguntasPgas ??
        SqlSyntax.setField(_fPreguntasPgas, 'preguntasPgas', DbType.bool);
  }

  static TableField? _fCuestionarioHabitabilidad;
  static TableField get cuestionarioHabitabilidad {
    return _fCuestionarioHabitabilidad = _fCuestionarioHabitabilidad ??
        SqlSyntax.setField(_fCuestionarioHabitabilidad,
            'cuestionarioHabitabilidad', DbType.bool);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ViviendaFields

//region ViviendaManager
class ViviendaManager extends SqfEntityProvider {
  ViviendaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'vivienda';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ViviendaManager
// region Ubicacion
class Ubicacion extends TableBase {
  Ubicacion(
      {this.region,
      this.provincia,
      this.localidad,
      this.barrio,
      this.direccion,
      this.planta,
      this.latitud,
      this.longitud,
      this.dateCreated}) {
    _setDefaultValues();
  }
  Ubicacion.withFields(
      this.region,
      this.provincia,
      this.localidad,
      this.barrio,
      this.direccion,
      this.planta,
      this.latitud,
      this.longitud,
      this.dateCreated) {
    _setDefaultValues();
  }
  Ubicacion.withId(
      this.region,
      this.provincia,
      this.localidad,
      this.barrio,
      this.direccion,
      this.planta,
      this.latitud,
      this.longitud,
      this._id,
      this.dateCreated) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Ubicacion.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['region'] != null) {
      region = o['region'].toString();
    }
    if (o['provincia'] != null) {
      provincia = o['provincia'].toString();
    }
    if (o['localidad'] != null) {
      localidad = o['localidad'].toString();
    }
    if (o['barrio'] != null) {
      barrio = o['barrio'].toString();
    }
    if (o['direccion'] != null) {
      direccion = o['direccion'].toString();
    }
    if (o['planta'] != null) {
      planta = o['planta'].toString();
    }
    if (o['latitud'] != null) {
      latitud = double.tryParse(o['latitud'].toString());
    }
    if (o['longitud'] != null) {
      longitud = double.tryParse(o['longitud'].toString());
    }
    _id = int.tryParse(o['_id'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Ubicacion)
  String? region;
  String? provincia;
  String? localidad;
  String? barrio;
  String? direccion;
  String? planta;
  double? latitud;
  double? longitud;
  int? _id;
  DateTime? dateCreated;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Ubicacion)

  static const bool _softDeleteActivated = false;
  UbicacionManager? __mnUbicacion;

  UbicacionManager get _mnUbicacion {
    return __mnUbicacion = __mnUbicacion ?? UbicacionManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['region'] = region;
    map['provincia'] = provincia;
    map['localidad'] = localidad;
    map['barrio'] = barrio;
    map['direccion'] = direccion;
    map['planta'] = planta;
    map['latitud'] = latitud;
    map['longitud'] = longitud;
    map['_id'] = _id;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['region'] = region;
    map['provincia'] = provincia;
    map['localidad'] = localidad;
    map['barrio'] = barrio;
    map['direccion'] = direccion;
    map['planta'] = planta;
    map['latitud'] = latitud;
    map['longitud'] = longitud;
    map['_id'] = _id;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }

    return map;
  }

  /// This method returns Json String [Ubicacion]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Ubicacion]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      region,
      provincia,
      localidad,
      barrio,
      direccion,
      planta,
      latitud,
      longitud,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      region,
      provincia,
      localidad,
      barrio,
      direccion,
      planta,
      latitud,
      longitud,
      _id,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<Ubicacion>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Ubicacion.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Ubicacion>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Ubicacion>[];
    try {
      objList = list
          .map((ubicacion) =>
              Ubicacion.fromMap(ubicacion as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Ubicacion.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Ubicacion>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Ubicacion> objList = <Ubicacion>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Ubicacion.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Ubicacion by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? _id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Ubicacion] if exist, otherwise returns null
  Future<Ubicacion?> getById(int? _id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (_id == null) {
      return null;
    }
    Ubicacion? obj;
    final data = await _mnUbicacion.getById([_id]);
    if (data.length != 0) {
      obj = Ubicacion.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Ubicacion) object. If the _id field is null, saves as a new record and returns new _id, if _id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns _id
  Future<int?> _save({bool ignoreBatch = true}) async {
    if (_id == null || _id == 0 || !isSaved!) {
      await _mnUbicacion.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // _id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUbicacion.update(this);
    }

    return _id;
  }

  /// Saves the (Ubicacion) object. If the _id field is null, saves as a new record and returns new _id, if _id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns _id
  Future<int?> _saveOrThrow({bool ignoreBatch = true}) async {
    if (_id == null || _id == 0 || !isSaved!) {
      await _mnUbicacion.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // _id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnUbicacion.updateOrThrow(this);
    }

    return _id;
  }

  void rollbackId() {
    if (isInsert == true) {
      _id = null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns _id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUbicacion.rawInsert(
          'INSERT OR REPLACE INTO ubicacion ( region, provincia, localidad, barrio, direccion, planta, latitud, longitud, _id, dateCreated)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            region,
            provincia,
            localidad,
            barrio,
            direccion,
            planta,
            latitud,
            longitud,
            _id,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Ubicacion _id=$_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Ubicacion _id=$_id did not update');
      }
      return _id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Ubicacion Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Ubicacion

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Ubicacion invoked (_id=$_id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUbicacion
          .delete(QueryParams(whereString: '_id=?', whereArguments: [_id]));
    } else {
      return _mnUbicacion.updateBatch(
          QueryParams(whereString: '_id=?', whereArguments: [_id]),
          {'isDeleted': 1});
    }
  }

  UbicacionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UbicacionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  UbicacionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return UbicacionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion ubicacion

// region UbicacionField
class UbicacionField extends SearchCriteria {
  UbicacionField(this.ubicacionFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  UbicacionFilterBuilder ubicacionFB;

  UbicacionField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  UbicacionFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    ubicacionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, ubicacionFB.parameters, param, SqlSyntax.EQuals,
            ubicacionFB._addedBlocks)
        : setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.NotEQuals, ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    ubicacionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.EQualsOrNull, ubicacionFB._addedBlocks)
        : setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder isNull() {
    ubicacionFB._addedBlocks = setCriteria(
        0,
        ubicacionFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      ubicacionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          ubicacionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          ubicacionFB._addedBlocks);
      _waitingNot = '';
      ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
          ubicacionFB._addedBlocks.retVal;
    }
    return ubicacionFB;
  }

  UbicacionFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      ubicacionFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          ubicacionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          ubicacionFB._addedBlocks);
      _waitingNot = '';
      ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
          ubicacionFB._addedBlocks.retVal;
      ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
          ubicacionFB._addedBlocks.retVal;
    }
    return ubicacionFB;
  }

  UbicacionFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      ubicacionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          ubicacionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          ubicacionFB._addedBlocks);
      _waitingNot = '';
      ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
          ubicacionFB._addedBlocks.retVal;
    }
    return ubicacionFB;
  }

  UbicacionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      ubicacionFB._addedBlocks = setCriteria(
          pFirst,
          ubicacionFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          ubicacionFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        ubicacionFB._addedBlocks = setCriteria(pFirst, ubicacionFB.parameters,
            param, SqlSyntax.LessThan, ubicacionFB._addedBlocks);
      } else {
        ubicacionFB._addedBlocks = setCriteria(pFirst, ubicacionFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, ubicacionFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        ubicacionFB._addedBlocks = setCriteria(pLast, ubicacionFB.parameters,
            param, SqlSyntax.GreaterThan, ubicacionFB._addedBlocks);
      } else {
        ubicacionFB._addedBlocks = setCriteria(pLast, ubicacionFB.parameters,
            param, SqlSyntax.LessThanOrEquals, ubicacionFB._addedBlocks);
      }
    }
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    ubicacionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.GreaterThan, ubicacionFB._addedBlocks)
        : setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    ubicacionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, ubicacionFB.parameters, param, SqlSyntax.LessThan,
            ubicacionFB._addedBlocks)
        : setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    ubicacionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, ubicacionFB._addedBlocks)
        : setCriteria(pValue, ubicacionFB.parameters, param, SqlSyntax.LessThan,
            ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    ubicacionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, ubicacionFB._addedBlocks)
        : setCriteria(pValue, ubicacionFB.parameters, param,
            SqlSyntax.GreaterThan, ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }

  UbicacionFilterBuilder inValues(dynamic pValue) {
    ubicacionFB._addedBlocks = setCriteria(
        pValue,
        ubicacionFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        ubicacionFB._addedBlocks);
    _waitingNot = '';
    ubicacionFB._addedBlocks.needEndBlock![ubicacionFB._blockIndex] =
        ubicacionFB._addedBlocks.retVal;
    return ubicacionFB;
  }
}
// endregion UbicacionField

// region UbicacionFilterBuilder
class UbicacionFilterBuilder extends SearchCriteria {
  UbicacionFilterBuilder(Ubicacion obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Ubicacion? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  UbicacionFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  UbicacionFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  UbicacionFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  UbicacionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  UbicacionFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  UbicacionFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  UbicacionFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UbicacionFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UbicacionFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  UbicacionFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  UbicacionFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  UbicacionField setField(
      UbicacionField? field, String colName, DbType dbtype) {
    return UbicacionField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  UbicacionField? _region;
  UbicacionField get region {
    return _region = setField(_region, 'region', DbType.text);
  }

  UbicacionField? _provincia;
  UbicacionField get provincia {
    return _provincia = setField(_provincia, 'provincia', DbType.text);
  }

  UbicacionField? _localidad;
  UbicacionField get localidad {
    return _localidad = setField(_localidad, 'localidad', DbType.text);
  }

  UbicacionField? _barrio;
  UbicacionField get barrio {
    return _barrio = setField(_barrio, 'barrio', DbType.text);
  }

  UbicacionField? _direccion;
  UbicacionField get direccion {
    return _direccion = setField(_direccion, 'direccion', DbType.text);
  }

  UbicacionField? _planta;
  UbicacionField get planta {
    return _planta = setField(_planta, 'planta', DbType.text);
  }

  UbicacionField? _latitud;
  UbicacionField get latitud {
    return _latitud = setField(_latitud, 'latitud', DbType.real);
  }

  UbicacionField? _longitud;
  UbicacionField get longitud {
    return _longitud = setField(_longitud, 'longitud', DbType.real);
  }

  UbicacionField? __id;
  UbicacionField get _id {
    return __id = setField(__id, '_id', DbType.integer);
  }

  UbicacionField? _dateCreated;
  UbicacionField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Ubicacion._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Ubicacion> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Ubicacion._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnUbicacion.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnUbicacion.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          '_id IN (SELECT _id from ubicacion ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnUbicacion.updateBatch(qparams, values);
  }

  /// This method always returns [Ubicacion] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Ubicacion?
  Future<Ubicacion?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnUbicacion.toList(qparams);
    final data = await objFuture;
    Ubicacion? obj;
    if (data.isNotEmpty) {
      obj = Ubicacion.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Ubicacion]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Ubicacion?
  Future<Ubicacion> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Ubicacion();
  }

  /// This method returns int. [Ubicacion]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? ubicacionCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final ubicacionsFuture = await _obj!._mnUbicacion.toList(qparams);
    final int count = ubicacionsFuture[0]['CNT'] as int;
    if (ubicacionCount != null) {
      ubicacionCount(count);
    }
    return count;
  }

  /// This method returns List<Ubicacion> [Ubicacion]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Ubicacion>
  Future<List<Ubicacion>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Ubicacion> ubicacionsData = await Ubicacion.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return ubicacionsData;
  }

  /// This method returns Json String [Ubicacion]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Ubicacion]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Ubicacion]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnUbicacion.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Ubicacion]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `_id` FROM ubicacion WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> _idData = <int>[];
    qparams.selectColumns = ['_id'];
    final _idFuture = await _obj!._mnUbicacion.toList(qparams);

    final int count = _idFuture.length;
    for (int i = 0; i < count; i++) {
      _idData.add(_idFuture[i]['_id'] as int);
    }
    return _idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Ubicacion]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnUbicacion.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Ubicacion.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnUbicacion.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion UbicacionFilterBuilder

// region UbicacionFields
class UbicacionFields {
  static TableField? _fRegion;
  static TableField get region {
    return _fRegion =
        _fRegion ?? SqlSyntax.setField(_fRegion, 'region', DbType.text);
  }

  static TableField? _fProvincia;
  static TableField get provincia {
    return _fProvincia = _fProvincia ??
        SqlSyntax.setField(_fProvincia, 'provincia', DbType.text);
  }

  static TableField? _fLocalidad;
  static TableField get localidad {
    return _fLocalidad = _fLocalidad ??
        SqlSyntax.setField(_fLocalidad, 'localidad', DbType.text);
  }

  static TableField? _fBarrio;
  static TableField get barrio {
    return _fBarrio =
        _fBarrio ?? SqlSyntax.setField(_fBarrio, 'barrio', DbType.text);
  }

  static TableField? _fDireccion;
  static TableField get direccion {
    return _fDireccion = _fDireccion ??
        SqlSyntax.setField(_fDireccion, 'direccion', DbType.text);
  }

  static TableField? _fPlanta;
  static TableField get planta {
    return _fPlanta =
        _fPlanta ?? SqlSyntax.setField(_fPlanta, 'planta', DbType.text);
  }

  static TableField? _fLatitud;
  static TableField get latitud {
    return _fLatitud =
        _fLatitud ?? SqlSyntax.setField(_fLatitud, 'latitud', DbType.real);
  }

  static TableField? _fLongitud;
  static TableField get longitud {
    return _fLongitud =
        _fLongitud ?? SqlSyntax.setField(_fLongitud, 'longitud', DbType.real);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }
}
// endregion UbicacionFields

//region UbicacionManager
class UbicacionManager extends SqfEntityProvider {
  UbicacionManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ubicacion';
  static const List<String> _primaryKeyList = ['_id'];
  static const String _whereStr = '_id=?';
}

//endregion UbicacionManager
// region Certificado
class Certificado extends TableBase {
  Certificado(
      {this.id,
      this.monto,
      this.fecha,
      this.pdf,
      this.cargadoServidor,
      this.obraId,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Certificado.withFields(this.monto, this.fecha, this.pdf, this.cargadoServidor,
      this.obraId, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Certificado.withId(this.id, this.monto, this.fecha, this.pdf,
      this.cargadoServidor, this.obraId, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Certificado.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['monto'] != null) {
      monto = double.tryParse(o['monto'].toString());
    }
    if (o['fecha'] != null) {
      fecha = int.tryParse(o['fecha'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['fecha'].toString())!)
          : DateTime.tryParse(o['fecha'].toString());
    }
    if (o['pdf'] != null) {
      pdf = o['pdf'] as Uint8List;
    }
    if (o['cargadoServidor'] != null) {
      cargadoServidor = o['cargadoServidor'].toString() == '1' ||
          o['cargadoServidor'].toString() == 'true';
    }
    obraId = int.tryParse(o['obraId'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plObra = o['obra'] != null
        ? Obra.fromMap(o['obra'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Certificado)
  int? id;
  double? monto;
  DateTime? fecha;
  Uint8List? pdf;
  bool? cargadoServidor;
  int? obraId;
  DateTime? dateCreated;
  bool? isDeleted;

  BoolResult? saveResult;
  // end FIELDS (Certificado)

// RELATIONSHIPS (Certificado)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plObra', 'plField2'..]) or so on..
  Obra? plObra;

  /// get Obra By ObraId
  Future<Obra?> getObra(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Obra()
        .getById(obraId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Certificado)

  static const bool _softDeleteActivated = true;
  CertificadoManager? __mnCertificado;

  CertificadoManager get _mnCertificado {
    return __mnCertificado = __mnCertificado ?? CertificadoManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['monto'] = monto;
    if (fecha != null) {
      map['fecha'] = forJson
          ? '$fecha!.year-$fecha!.month-$fecha!.day'
          : forQuery
              ? DateTime(fecha!.year, fecha!.month, fecha!.day)
                  .millisecondsSinceEpoch
              : fecha;
    } else {
      map['fecha'] = null;
    }
    map['pdf'] = pdf;
    if (cargadoServidor != null) {
      map['cargadoServidor'] =
          forQuery ? (cargadoServidor! ? 1 : 0) : cargadoServidor;
    } else {
      map['cargadoServidor'] = null;
    }
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['monto'] = monto;
    if (fecha != null) {
      map['fecha'] = forJson
          ? '$fecha!.year-$fecha!.month-$fecha!.day'
          : forQuery
              ? DateTime(fecha!.year, fecha!.month, fecha!.day)
                  .millisecondsSinceEpoch
              : fecha;
    } else {
      map['fecha'] = null;
    }
    map['pdf'] = pdf;
    if (cargadoServidor != null) {
      map['cargadoServidor'] =
          forQuery ? (cargadoServidor! ? 1 : 0) : cargadoServidor;
    } else {
      map['cargadoServidor'] = null;
    }
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Certificado]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Certificado]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      monto,
      fecha != null ? fecha!.millisecondsSinceEpoch : null,
      pdf,
      cargadoServidor,
      obraId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      monto,
      fecha != null ? fecha!.millisecondsSinceEpoch : null,
      pdf,
      cargadoServidor,
      obraId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Certificado>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Certificado.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Certificado>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Certificado>[];
    try {
      objList = list
          .map((certificado) =>
              Certificado.fromMap(certificado as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Certificado.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Certificado>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Certificado> objList = <Certificado>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Certificado.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Certificado by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Certificado] if exist, otherwise returns null
  Future<Certificado?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Certificado? obj;
    final data = await _mnCertificado.getById([id]);
    if (data.length != 0) {
      obj = Certificado.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Certificado) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCertificado.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCertificado.update(this);
    }

    return id;
  }

  /// Saves the (Certificado) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCertificado.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCertificado.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Certificado. Returns a new Primary Key value of Certificado

  /// <returns>Returns a new Primary Key value of Certificado
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Certificado> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Certificado> certificados) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in certificados) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
      for (int i = 0; i < certificados.length; i++) {
        if (certificados[i].id == null) {
          certificados[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCertificado.rawInsert(
          'INSERT OR REPLACE INTO certificado (id, monto, fecha, pdf, cargadoServidor, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            monto,
            fecha != null ? fecha!.millisecondsSinceEpoch : null,
            pdf,
            cargadoServidor,
            obraId,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Certificado id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Certificado id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Certificado Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Certificado>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Certificado> certificados) async {
    final results = await _mnCertificado.rawInsertAll(
        'INSERT OR REPLACE INTO certificado (id, monto, fecha, pdf, cargadoServidor, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?)',
        certificados);
    return results;
  }

  /// Deletes Certificado

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Certificado invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnCertificado
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCertificado.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Certificado>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Certificado invoked (id=$id)');
    {
      return _mnCertificado.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  CertificadoFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CertificadoFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  CertificadoFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CertificadoFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    cargadoServidor = cargadoServidor ?? false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion certificado

// region CertificadoField
class CertificadoField extends SearchCriteria {
  CertificadoField(this.certificadoFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  CertificadoFilterBuilder certificadoFB;

  CertificadoField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  CertificadoFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    certificadoFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, certificadoFB.parameters, param, SqlSyntax.EQuals,
            certificadoFB._addedBlocks)
        : setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.NotEQuals, certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    certificadoFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.EQualsOrNull, certificadoFB._addedBlocks)
        : setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder isNull() {
    certificadoFB._addedBlocks = setCriteria(
        0,
        certificadoFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      certificadoFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          certificadoFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          certificadoFB._addedBlocks);
      _waitingNot = '';
      certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
          certificadoFB._addedBlocks.retVal;
    }
    return certificadoFB;
  }

  CertificadoFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      certificadoFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          certificadoFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          certificadoFB._addedBlocks);
      _waitingNot = '';
      certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
          certificadoFB._addedBlocks.retVal;
      certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
          certificadoFB._addedBlocks.retVal;
    }
    return certificadoFB;
  }

  CertificadoFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      certificadoFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          certificadoFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          certificadoFB._addedBlocks);
      _waitingNot = '';
      certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
          certificadoFB._addedBlocks.retVal;
    }
    return certificadoFB;
  }

  CertificadoFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      certificadoFB._addedBlocks = setCriteria(
          pFirst,
          certificadoFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          certificadoFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        certificadoFB._addedBlocks = setCriteria(
            pFirst,
            certificadoFB.parameters,
            param,
            SqlSyntax.LessThan,
            certificadoFB._addedBlocks);
      } else {
        certificadoFB._addedBlocks = setCriteria(
            pFirst,
            certificadoFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            certificadoFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        certificadoFB._addedBlocks = setCriteria(
            pLast,
            certificadoFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            certificadoFB._addedBlocks);
      } else {
        certificadoFB._addedBlocks = setCriteria(
            pLast,
            certificadoFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            certificadoFB._addedBlocks);
      }
    }
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    certificadoFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.GreaterThan, certificadoFB._addedBlocks)
        : setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.LessThanOrEquals, certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    certificadoFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.LessThan, certificadoFB._addedBlocks)
        : setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    certificadoFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, certificadoFB._addedBlocks)
        : setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.LessThan, certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    certificadoFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.LessThanOrEquals, certificadoFB._addedBlocks)
        : setCriteria(pValue, certificadoFB.parameters, param,
            SqlSyntax.GreaterThan, certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }

  CertificadoFilterBuilder inValues(dynamic pValue) {
    certificadoFB._addedBlocks = setCriteria(
        pValue,
        certificadoFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        certificadoFB._addedBlocks);
    _waitingNot = '';
    certificadoFB._addedBlocks.needEndBlock![certificadoFB._blockIndex] =
        certificadoFB._addedBlocks.retVal;
    return certificadoFB;
  }
}
// endregion CertificadoField

// region CertificadoFilterBuilder
class CertificadoFilterBuilder extends SearchCriteria {
  CertificadoFilterBuilder(Certificado obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Certificado? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  CertificadoFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  CertificadoFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  CertificadoFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  CertificadoFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  CertificadoFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  CertificadoFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  CertificadoFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CertificadoFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CertificadoFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CertificadoFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CertificadoFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  CertificadoField setField(
      CertificadoField? field, String colName, DbType dbtype) {
    return CertificadoField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  CertificadoField? _id;
  CertificadoField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  CertificadoField? _monto;
  CertificadoField get monto {
    return _monto = setField(_monto, 'monto', DbType.real);
  }

  CertificadoField? _fecha;
  CertificadoField get fecha {
    return _fecha = setField(_fecha, 'fecha', DbType.date);
  }

  CertificadoField? _pdf;
  CertificadoField get pdf {
    return _pdf = setField(_pdf, 'pdf', DbType.blob);
  }

  CertificadoField? _cargadoServidor;
  CertificadoField get cargadoServidor {
    return _cargadoServidor =
        setField(_cargadoServidor, 'cargadoServidor', DbType.bool);
  }

  CertificadoField? _obraId;
  CertificadoField get obraId {
    return _obraId = setField(_obraId, 'obraId', DbType.integer);
  }

  CertificadoField? _dateCreated;
  CertificadoField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  CertificadoField? _isDeleted;
  CertificadoField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Certificado._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Certificado> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Certificado._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnCertificado.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnCertificado.delete(qparams);
    }
    return r;
  }

  /// Recover List<Certificado> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover Certificado bulk invoked');
    return _obj!._mnCertificado.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from certificado ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnCertificado.updateBatch(qparams, values);
  }

  /// This method always returns [Certificado] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Certificado?
  Future<Certificado?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnCertificado.toList(qparams);
    final data = await objFuture;
    Certificado? obj;
    if (data.isNotEmpty) {
      obj = Certificado.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Certificado]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Certificado?
  Future<Certificado> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Certificado();
  }

  /// This method returns int. [Certificado]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? certificadoCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final certificadosFuture = await _obj!._mnCertificado.toList(qparams);
    final int count = certificadosFuture[0]['CNT'] as int;
    if (certificadoCount != null) {
      certificadoCount(count);
    }
    return count;
  }

  /// This method returns List<Certificado> [Certificado]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Certificado>
  Future<List<Certificado>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Certificado> certificadosData = await Certificado.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return certificadosData;
  }

  /// This method returns Json String [Certificado]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Certificado]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Certificado]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnCertificado.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Certificado>>
  Future<List<DropdownMenuItem<Certificado>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Certificado>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final certificadosFuture = _obj!._mnCertificado.toList(qparams);

    final data = await certificadosFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Certificado>> items = []..add(DropdownMenuItem(
        value: Certificado(),
        child: Text('Select Certificado'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Certificado.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final certificadosFuture = _obj!._mnCertificado.toList(qparams);

    final data = await certificadosFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Certificado'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Certificado]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM certificado WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnCertificado.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Certificado]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnCertificado.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Certificado.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnCertificado.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CertificadoFilterBuilder

// region CertificadoFields
class CertificadoFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fMonto;
  static TableField get monto {
    return _fMonto =
        _fMonto ?? SqlSyntax.setField(_fMonto, 'monto', DbType.real);
  }

  static TableField? _fFecha;
  static TableField get fecha {
    return _fFecha =
        _fFecha ?? SqlSyntax.setField(_fFecha, 'fecha', DbType.date);
  }

  static TableField? _fPdf;
  static TableField get pdf {
    return _fPdf = _fPdf ?? SqlSyntax.setField(_fPdf, 'pdf', DbType.blob);
  }

  static TableField? _fCargadoServidor;
  static TableField get cargadoServidor {
    return _fCargadoServidor = _fCargadoServidor ??
        SqlSyntax.setField(_fCargadoServidor, 'cargadoServidor', DbType.bool);
  }

  static TableField? _fObraId;
  static TableField get obraId {
    return _fObraId =
        _fObraId ?? SqlSyntax.setField(_fObraId, 'obraId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion CertificadoFields

//region CertificadoManager
class CertificadoManager extends SqfEntityProvider {
  CertificadoManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'certificado';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CertificadoManager
// region Visita
class Visita extends TableBase {
  Visita(
      {this.id,
      this.numVisita,
      this.informeId,
      this.fecha,
      this.nombreRelevador,
      this.observaciones,
      this.visitaFinal,
      this.cargadoServidor,
      this.obraId,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Visita.withFields(
      this.numVisita,
      this.informeId,
      this.fecha,
      this.nombreRelevador,
      this.observaciones,
      this.visitaFinal,
      this.cargadoServidor,
      this.obraId,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  Visita.withId(
      this.id,
      this.numVisita,
      this.informeId,
      this.fecha,
      this.nombreRelevador,
      this.observaciones,
      this.visitaFinal,
      this.cargadoServidor,
      this.obraId,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Visita.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['numVisita'] != null) {
      numVisita = int.tryParse(o['numVisita'].toString());
    }
    if (o['informeId'] != null) {
      informeId = int.tryParse(o['informeId'].toString());
    }
    if (o['fecha'] != null) {
      fecha = int.tryParse(o['fecha'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['fecha'].toString())!)
          : DateTime.tryParse(o['fecha'].toString());
    }
    if (o['nombreRelevador'] != null) {
      nombreRelevador = o['nombreRelevador'].toString();
    }
    if (o['observaciones'] != null) {
      observaciones = o['observaciones'].toString();
    }
    if (o['visitaFinal'] != null) {
      visitaFinal = o['visitaFinal'].toString() == '1' ||
          o['visitaFinal'].toString() == 'true';
    }
    if (o['cargadoServidor'] != null) {
      cargadoServidor = o['cargadoServidor'].toString() == '1' ||
          o['cargadoServidor'].toString() == 'true';
    }
    obraId = int.tryParse(o['obraId'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plObra = o['obra'] != null
        ? Obra.fromMap(o['obra'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Visita)
  int? id;
  int? numVisita;
  int? informeId;
  DateTime? fecha;
  String? nombreRelevador;
  String? observaciones;
  bool? visitaFinal;
  bool? cargadoServidor;
  int? obraId;
  DateTime? dateCreated;
  bool? isDeleted;

  BoolResult? saveResult;
  // end FIELDS (Visita)

// RELATIONSHIPS (Visita)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plObra', 'plField2'..]) or so on..
  Obra? plObra;

  /// get Obra By ObraId
  Future<Obra?> getObra(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Obra()
        .getById(obraId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Visita)

// COLLECTIONS & VIRTUALS (Visita)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRespuestaVisitas', 'plField2'..]) or so on..
  List<RespuestaVisita>? plRespuestaVisitas;

  /// get RespuestaVisita(s) filtered by id=visitaId
  RespuestaVisitaFilterBuilder? getRespuestaVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return RespuestaVisita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .visitaId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFotoVisitas', 'plField2'..]) or so on..
  List<FotoVisita>? plFotoVisitas;

  /// get FotoVisita(s) filtered by id=visitaId
  FotoVisitaFilterBuilder? getFotoVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return FotoVisita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .visitaId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Visita)

  static const bool _softDeleteActivated = true;
  VisitaManager? __mnVisita;

  VisitaManager get _mnVisita {
    return __mnVisita = __mnVisita ?? VisitaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['numVisita'] = numVisita;
    map['informeId'] = informeId;
    if (fecha != null) {
      map['fecha'] = forJson
          ? '$fecha!.year-$fecha!.month-$fecha!.day'
          : forQuery
              ? DateTime(fecha!.year, fecha!.month, fecha!.day)
                  .millisecondsSinceEpoch
              : fecha;
    } else {
      map['fecha'] = null;
    }
    map['nombreRelevador'] = nombreRelevador;
    map['observaciones'] = observaciones;
    if (visitaFinal != null) {
      map['visitaFinal'] = forQuery ? (visitaFinal! ? 1 : 0) : visitaFinal;
    } else {
      map['visitaFinal'] = null;
    }
    if (cargadoServidor != null) {
      map['cargadoServidor'] =
          forQuery ? (cargadoServidor! ? 1 : 0) : cargadoServidor;
    } else {
      map['cargadoServidor'] = null;
    }
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['numVisita'] = numVisita;
    map['informeId'] = informeId;
    if (fecha != null) {
      map['fecha'] = forJson
          ? '$fecha!.year-$fecha!.month-$fecha!.day'
          : forQuery
              ? DateTime(fecha!.year, fecha!.month, fecha!.day)
                  .millisecondsSinceEpoch
              : fecha;
    } else {
      map['fecha'] = null;
    }
    map['nombreRelevador'] = nombreRelevador;
    map['observaciones'] = observaciones;
    if (visitaFinal != null) {
      map['visitaFinal'] = forQuery ? (visitaFinal! ? 1 : 0) : visitaFinal;
    } else {
      map['visitaFinal'] = null;
    }
    if (cargadoServidor != null) {
      map['cargadoServidor'] =
          forQuery ? (cargadoServidor! ? 1 : 0) : cargadoServidor;
    } else {
      map['cargadoServidor'] = null;
    }
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Visita)
    if (!forQuery) {
      map['RespuestaVisitas'] = await getRespuestaVisitas()!.toMapList();
    }
    if (!forQuery) {
      map['FotoVisitas'] = await getFotoVisitas()!.toMapList();
    }
// END COLLECTIONS (Visita)

    return map;
  }

  /// This method returns Json String [Visita]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Visita]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      numVisita,
      informeId,
      fecha != null ? fecha!.millisecondsSinceEpoch : null,
      nombreRelevador,
      observaciones,
      visitaFinal,
      cargadoServidor,
      obraId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      numVisita,
      informeId,
      fecha != null ? fecha!.millisecondsSinceEpoch : null,
      nombreRelevador,
      observaciones,
      visitaFinal,
      cargadoServidor,
      obraId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Visita>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Visita.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Visita>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Visita>[];
    try {
      objList = list
          .map((visita) => Visita.fromMap(visita as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Visita.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Visita>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Visita> objList = <Visita>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Visita.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('visita.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('visita.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('visita.plFotoVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoVisitas'))) {
          /*_loadedfields!.add('visita.plFotoVisitas'); */ obj.plFotoVisitas =
              obj.plFotoVisitas ??
                  await obj.getFotoVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Visita by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Visita] if exist, otherwise returns null
  Future<Visita?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Visita? obj;
    final data = await _mnVisita.getById([id]);
    if (data.length != 0) {
      obj = Visita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('visita.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('visita.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('visita.plFotoVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoVisitas'))) {
          /*_loadedfields!.add('visita.plFotoVisitas'); */ obj.plFotoVisitas =
              obj.plFotoVisitas ??
                  await obj.getFotoVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Visita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnVisita.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVisita.update(this);
    }

    return id;
  }

  /// Saves the (Visita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnVisita.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVisita.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Visita. Returns a new Primary Key value of Visita

  /// <returns>Returns a new Primary Key value of Visita
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Visita> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Visita> visitas) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in visitas) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
      for (int i = 0; i < visitas.length; i++) {
        if (visitas[i].id == null) {
          visitas[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVisita.rawInsert(
          'INSERT OR REPLACE INTO visita (id, numVisita, informeId, fecha, nombreRelevador, observaciones, visitaFinal, cargadoServidor, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            numVisita,
            informeId,
            fecha != null ? fecha!.millisecondsSinceEpoch : null,
            nombreRelevador,
            observaciones,
            visitaFinal,
            cargadoServidor,
            obraId,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Visita id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Visita id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Visita Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Visita>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Visita> visitas) async {
    final results = await _mnVisita.rawInsertAll(
        'INSERT OR REPLACE INTO visita (id, numVisita, informeId, fecha, nombreRelevador, observaciones, visitaFinal, cargadoServidor, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        visitas);
    return results;
  }

  /// Deletes Visita

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Visita invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await RespuestaVisita()
          .select()
          .visitaId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await FotoVisita()
          .select()
          .visitaId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnVisita
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Visita>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Visita invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await RespuestaVisita()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .visitaId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await FotoVisita()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .visitaId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  VisitaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  VisitaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    fecha = fecha ?? DateTime.now();
    visitaFinal = visitaFinal ?? false;
    cargadoServidor = cargadoServidor ?? false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion visita

// region VisitaField
class VisitaField extends SearchCriteria {
  VisitaField(this.visitaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  VisitaFilterBuilder visitaFB;

  VisitaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  VisitaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    visitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, visitaFB.parameters, param, SqlSyntax.EQuals,
            visitaFB._addedBlocks)
        : setCriteria(pValue, visitaFB.parameters, param, SqlSyntax.NotEQuals,
            visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    visitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, visitaFB.parameters, param,
            SqlSyntax.EQualsOrNull, visitaFB._addedBlocks)
        : setCriteria(pValue, visitaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder isNull() {
    visitaFB._addedBlocks = setCriteria(
        0,
        visitaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      visitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          visitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          visitaFB._addedBlocks);
      _waitingNot = '';
      visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
          visitaFB._addedBlocks.retVal;
    }
    return visitaFB;
  }

  VisitaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      visitaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          visitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          visitaFB._addedBlocks);
      _waitingNot = '';
      visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
          visitaFB._addedBlocks.retVal;
      visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
          visitaFB._addedBlocks.retVal;
    }
    return visitaFB;
  }

  VisitaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      visitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          visitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          visitaFB._addedBlocks);
      _waitingNot = '';
      visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
          visitaFB._addedBlocks.retVal;
    }
    return visitaFB;
  }

  VisitaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      visitaFB._addedBlocks = setCriteria(
          pFirst,
          visitaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          visitaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        visitaFB._addedBlocks = setCriteria(pFirst, visitaFB.parameters, param,
            SqlSyntax.LessThan, visitaFB._addedBlocks);
      } else {
        visitaFB._addedBlocks = setCriteria(pFirst, visitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, visitaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        visitaFB._addedBlocks = setCriteria(pLast, visitaFB.parameters, param,
            SqlSyntax.GreaterThan, visitaFB._addedBlocks);
      } else {
        visitaFB._addedBlocks = setCriteria(pLast, visitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, visitaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    visitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, visitaFB.parameters, param, SqlSyntax.GreaterThan,
            visitaFB._addedBlocks)
        : setCriteria(pValue, visitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    visitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, visitaFB.parameters, param, SqlSyntax.LessThan,
            visitaFB._addedBlocks)
        : setCriteria(pValue, visitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    visitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, visitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, visitaFB._addedBlocks)
        : setCriteria(pValue, visitaFB.parameters, param, SqlSyntax.LessThan,
            visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    visitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, visitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, visitaFB._addedBlocks)
        : setCriteria(pValue, visitaFB.parameters, param, SqlSyntax.GreaterThan,
            visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }

  VisitaFilterBuilder inValues(dynamic pValue) {
    visitaFB._addedBlocks = setCriteria(
        pValue,
        visitaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        visitaFB._addedBlocks);
    _waitingNot = '';
    visitaFB._addedBlocks.needEndBlock![visitaFB._blockIndex] =
        visitaFB._addedBlocks.retVal;
    return visitaFB;
  }
}
// endregion VisitaField

// region VisitaFilterBuilder
class VisitaFilterBuilder extends SearchCriteria {
  VisitaFilterBuilder(Visita obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Visita? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  VisitaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  VisitaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  VisitaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  VisitaFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  VisitaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  VisitaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  VisitaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VisitaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VisitaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VisitaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VisitaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  VisitaField setField(VisitaField? field, String colName, DbType dbtype) {
    return VisitaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  VisitaField? _id;
  VisitaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  VisitaField? _numVisita;
  VisitaField get numVisita {
    return _numVisita = setField(_numVisita, 'numVisita', DbType.integer);
  }

  VisitaField? _informeId;
  VisitaField get informeId {
    return _informeId = setField(_informeId, 'informeId', DbType.integer);
  }

  VisitaField? _fecha;
  VisitaField get fecha {
    return _fecha = setField(_fecha, 'fecha', DbType.date);
  }

  VisitaField? _nombreRelevador;
  VisitaField get nombreRelevador {
    return _nombreRelevador =
        setField(_nombreRelevador, 'nombreRelevador', DbType.text);
  }

  VisitaField? _observaciones;
  VisitaField get observaciones {
    return _observaciones =
        setField(_observaciones, 'observaciones', DbType.text);
  }

  VisitaField? _visitaFinal;
  VisitaField get visitaFinal {
    return _visitaFinal = setField(_visitaFinal, 'visitaFinal', DbType.bool);
  }

  VisitaField? _cargadoServidor;
  VisitaField get cargadoServidor {
    return _cargadoServidor =
        setField(_cargadoServidor, 'cargadoServidor', DbType.bool);
  }

  VisitaField? _obraId;
  VisitaField get obraId {
    return _obraId = setField(_obraId, 'obraId', DbType.integer);
  }

  VisitaField? _dateCreated;
  VisitaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  VisitaField? _isDeleted;
  VisitaField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Visita._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Visita> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (RespuestaVisita) according to DeleteRule.CASCADE
    final idListRespuestaVisitaBYvisitaId = toListPrimaryKeySQL(false);
    final resRespuestaVisitaBYvisitaId = await RespuestaVisita()
        .select()
        .where('visitaId IN (${idListRespuestaVisitaBYvisitaId['sql']})',
            parameterValue: idListRespuestaVisitaBYvisitaId['args'])
        .delete(hardDelete);
    if (!resRespuestaVisitaBYvisitaId.success) {
      return resRespuestaVisitaBYvisitaId;
    }
// Delete sub records where in (FotoVisita) according to DeleteRule.CASCADE
    final idListFotoVisitaBYvisitaId = toListPrimaryKeySQL(false);
    final resFotoVisitaBYvisitaId = await FotoVisita()
        .select()
        .where('visitaId IN (${idListFotoVisitaBYvisitaId['sql']})',
            parameterValue: idListFotoVisitaBYvisitaId['args'])
        .delete(hardDelete);
    if (!resFotoVisitaBYvisitaId.success) {
      return resFotoVisitaBYvisitaId;
    }

    if (Visita._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnVisita.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnVisita.delete(qparams);
    }
    return r;
  }

  /// Recover List<Visita> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover Visita bulk invoked');
    // Recover sub records where in (RespuestaVisita) according to DeleteRule.CASCADE
    final idListRespuestaVisitaBYvisitaId = toListPrimaryKeySQL(false);
    final resRespuestaVisitaBYvisitaId = await RespuestaVisita()
        .select()
        .where('visitaId IN (${idListRespuestaVisitaBYvisitaId['sql']})',
            parameterValue: idListRespuestaVisitaBYvisitaId['args'])
        .update({'isDeleted': 0});
    if (!resRespuestaVisitaBYvisitaId.success) {
      return resRespuestaVisitaBYvisitaId;
    }
// Recover sub records where in (FotoVisita) according to DeleteRule.CASCADE
    final idListFotoVisitaBYvisitaId = toListPrimaryKeySQL(false);
    final resFotoVisitaBYvisitaId = await FotoVisita()
        .select()
        .where('visitaId IN (${idListFotoVisitaBYvisitaId['sql']})',
            parameterValue: idListFotoVisitaBYvisitaId['args'])
        .update({'isDeleted': 0});
    if (!resFotoVisitaBYvisitaId.success) {
      return resFotoVisitaBYvisitaId;
    }
    return _obj!._mnVisita.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from visita ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnVisita.updateBatch(qparams, values);
  }

  /// This method always returns [Visita] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Visita?
  Future<Visita?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnVisita.toList(qparams);
    final data = await objFuture;
    Visita? obj;
    if (data.isNotEmpty) {
      obj = Visita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('visita.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('visita.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('visita.plFotoVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoVisitas'))) {
          /*_loadedfields!.add('visita.plFotoVisitas'); */ obj.plFotoVisitas =
              obj.plFotoVisitas ??
                  await obj.getFotoVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Visita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Visita?
  Future<Visita> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Visita();
  }

  /// This method returns int. [Visita]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? visitaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final visitasFuture = await _obj!._mnVisita.toList(qparams);
    final int count = visitasFuture[0]['CNT'] as int;
    if (visitaCount != null) {
      visitaCount(count);
    }
    return count;
  }

  /// This method returns List<Visita> [Visita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Visita>
  Future<List<Visita>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Visita> visitasData = await Visita.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return visitasData;
  }

  /// This method returns Json String [Visita]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Visita]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Visita]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnVisita.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Visita>>
  Future<List<DropdownMenuItem<Visita>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Visita>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final visitasFuture = _obj!._mnVisita.toList(qparams);

    final data = await visitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Visita>> items = []..add(DropdownMenuItem(
        value: Visita(),
        child: Text('Select Visita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Visita.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final visitasFuture = _obj!._mnVisita.toList(qparams);

    final data = await visitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Visita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Visita]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM visita WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnVisita.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Visita]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnVisita.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Visita.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnVisita.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VisitaFilterBuilder

// region VisitaFields
class VisitaFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fNumVisita;
  static TableField get numVisita {
    return _fNumVisita = _fNumVisita ??
        SqlSyntax.setField(_fNumVisita, 'numVisita', DbType.integer);
  }

  static TableField? _fInformeId;
  static TableField get informeId {
    return _fInformeId = _fInformeId ??
        SqlSyntax.setField(_fInformeId, 'informeId', DbType.integer);
  }

  static TableField? _fFecha;
  static TableField get fecha {
    return _fFecha =
        _fFecha ?? SqlSyntax.setField(_fFecha, 'fecha', DbType.date);
  }

  static TableField? _fNombreRelevador;
  static TableField get nombreRelevador {
    return _fNombreRelevador = _fNombreRelevador ??
        SqlSyntax.setField(_fNombreRelevador, 'nombreRelevador', DbType.text);
  }

  static TableField? _fObservaciones;
  static TableField get observaciones {
    return _fObservaciones = _fObservaciones ??
        SqlSyntax.setField(_fObservaciones, 'observaciones', DbType.text);
  }

  static TableField? _fVisitaFinal;
  static TableField get visitaFinal {
    return _fVisitaFinal = _fVisitaFinal ??
        SqlSyntax.setField(_fVisitaFinal, 'visitaFinal', DbType.bool);
  }

  static TableField? _fCargadoServidor;
  static TableField get cargadoServidor {
    return _fCargadoServidor = _fCargadoServidor ??
        SqlSyntax.setField(_fCargadoServidor, 'cargadoServidor', DbType.bool);
  }

  static TableField? _fObraId;
  static TableField get obraId {
    return _fObraId =
        _fObraId ?? SqlSyntax.setField(_fObraId, 'obraId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion VisitaFields

//region VisitaManager
class VisitaManager extends SqfEntityProvider {
  VisitaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'visita';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion VisitaManager
// region PreguntaVisita
class PreguntaVisita extends TableBase {
  PreguntaVisita(
      {this.id,
      this.tipoRespuestaA,
      this.tipoRespuestaB,
      this.tipoRespuestaC,
      this.esTexto,
      this.pregunta,
      this.cuestionarioHabitabilidad,
      this.etapaDeAvance,
      this.intervencionId,
      this.dateCreated}) {
    _setDefaultValues();
  }
  PreguntaVisita.withFields(
      this.id,
      this.tipoRespuestaA,
      this.tipoRespuestaB,
      this.tipoRespuestaC,
      this.esTexto,
      this.pregunta,
      this.cuestionarioHabitabilidad,
      this.etapaDeAvance,
      this.intervencionId,
      this.dateCreated) {
    _setDefaultValues();
  }
  PreguntaVisita.withId(
      this.id,
      this.tipoRespuestaA,
      this.tipoRespuestaB,
      this.tipoRespuestaC,
      this.esTexto,
      this.pregunta,
      this.cuestionarioHabitabilidad,
      this.etapaDeAvance,
      this.intervencionId,
      this.dateCreated) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PreguntaVisita.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['tipoRespuestaA'] != null) {
      tipoRespuestaA = o['tipoRespuestaA'].toString();
    }
    if (o['tipoRespuestaB'] != null) {
      tipoRespuestaB = o['tipoRespuestaB'].toString();
    }
    if (o['tipoRespuestaC'] != null) {
      tipoRespuestaC = o['tipoRespuestaC'].toString();
    }
    if (o['esTexto'] != null) {
      esTexto =
          o['esTexto'].toString() == '1' || o['esTexto'].toString() == 'true';
    }
    if (o['pregunta'] != null) {
      pregunta = o['pregunta'].toString();
    }
    if (o['cuestionarioHabitabilidad'] != null) {
      cuestionarioHabitabilidad =
          o['cuestionarioHabitabilidad'].toString() == '1' ||
              o['cuestionarioHabitabilidad'].toString() == 'true';
    }
    if (o['etapaDeAvance'] != null) {
      etapaDeAvance = int.tryParse(o['etapaDeAvance'].toString());
    }
    intervencionId = int.tryParse(o['intervencionId'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }

    // RELATIONSHIPS FromMAP
    plIntervencion = o['intervencion'] != null
        ? Intervencion.fromMap(o['intervencion'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (PreguntaVisita)
  int? id;
  String? tipoRespuestaA;
  String? tipoRespuestaB;
  String? tipoRespuestaC;
  bool? esTexto;
  String? pregunta;
  bool? cuestionarioHabitabilidad;
  int? etapaDeAvance;
  int? intervencionId;
  DateTime? dateCreated;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (PreguntaVisita)

// RELATIONSHIPS (PreguntaVisita)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plIntervencion', 'plField2'..]) or so on..
  Intervencion? plIntervencion;

  /// get Intervencion By IntervencionId
  Future<Intervencion?> getIntervencion(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Intervencion().getById(intervencionId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (PreguntaVisita)

// COLLECTIONS & VIRTUALS (PreguntaVisita)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRespuestaVisitas', 'plField2'..]) or so on..
  List<RespuestaVisita>? plRespuestaVisitas;

  /// get RespuestaVisita(s) filtered by id=preguntaVisitaId
  RespuestaVisitaFilterBuilder? getRespuestaVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return RespuestaVisita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .preguntaVisitaId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (PreguntaVisita)

  static const bool _softDeleteActivated = false;
  PreguntaVisitaManager? __mnPreguntaVisita;

  PreguntaVisitaManager get _mnPreguntaVisita {
    return __mnPreguntaVisita = __mnPreguntaVisita ?? PreguntaVisitaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['tipoRespuestaA'] = tipoRespuestaA;
    map['tipoRespuestaB'] = tipoRespuestaB;
    map['tipoRespuestaC'] = tipoRespuestaC;
    if (esTexto != null) {
      map['esTexto'] = forQuery ? (esTexto! ? 1 : 0) : esTexto;
    } else {
      map['esTexto'] = null;
    }
    map['pregunta'] = pregunta;
    if (cuestionarioHabitabilidad != null) {
      map['cuestionarioHabitabilidad'] = forQuery
          ? (cuestionarioHabitabilidad! ? 1 : 0)
          : cuestionarioHabitabilidad;
    } else {
      map['cuestionarioHabitabilidad'] = null;
    }
    map['etapaDeAvance'] = etapaDeAvance;
    if (intervencionId != null) {
      map['intervencionId'] = forView
          ? plIntervencion == null
              ? intervencionId
              : plIntervencion!.nombre
          : intervencionId;
    } else {
      map['intervencionId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['tipoRespuestaA'] = tipoRespuestaA;
    map['tipoRespuestaB'] = tipoRespuestaB;
    map['tipoRespuestaC'] = tipoRespuestaC;
    if (esTexto != null) {
      map['esTexto'] = forQuery ? (esTexto! ? 1 : 0) : esTexto;
    } else {
      map['esTexto'] = null;
    }
    map['pregunta'] = pregunta;
    if (cuestionarioHabitabilidad != null) {
      map['cuestionarioHabitabilidad'] = forQuery
          ? (cuestionarioHabitabilidad! ? 1 : 0)
          : cuestionarioHabitabilidad;
    } else {
      map['cuestionarioHabitabilidad'] = null;
    }
    map['etapaDeAvance'] = etapaDeAvance;
    if (intervencionId != null) {
      map['intervencionId'] = forView
          ? plIntervencion == null
              ? intervencionId
              : plIntervencion!.nombre
          : intervencionId;
    } else {
      map['intervencionId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }

// COLLECTIONS (PreguntaVisita)
    if (!forQuery) {
      map['RespuestaVisitas'] = await getRespuestaVisitas()!.toMapList();
    }
// END COLLECTIONS (PreguntaVisita)

    return map;
  }

  /// This method returns Json String [PreguntaVisita]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PreguntaVisita]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      tipoRespuestaA,
      tipoRespuestaB,
      tipoRespuestaC,
      esTexto,
      pregunta,
      cuestionarioHabitabilidad,
      etapaDeAvance,
      intervencionId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      tipoRespuestaA,
      tipoRespuestaB,
      tipoRespuestaC,
      esTexto,
      pregunta,
      cuestionarioHabitabilidad,
      etapaDeAvance,
      intervencionId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
    ];
  }

  static Future<List<PreguntaVisita>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PreguntaVisita.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PreguntaVisita>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PreguntaVisita>[];
    try {
      objList = list
          .map((preguntavisita) =>
              PreguntaVisita.fromMap(preguntavisita as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PreguntaVisita.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PreguntaVisita>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PreguntaVisita> objList = <PreguntaVisita>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PreguntaVisita.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('preguntaVisita.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('preguntaVisita.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PreguntaVisita by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [PreguntaVisita] if exist, otherwise returns null
  Future<PreguntaVisita?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    PreguntaVisita? obj;
    final data = await _mnPreguntaVisita.getById([id]);
    if (data.length != 0) {
      obj = PreguntaVisita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('preguntaVisita.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('preguntaVisita.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PreguntaVisita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnPreguntaVisita.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPreguntaVisita.update(this);
    }

    return id;
  }

  /// Saves the (PreguntaVisita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnPreguntaVisita.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPreguntaVisita.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<PreguntaVisita> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PreguntaVisita> preguntavisitas) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in preguntavisitas) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPreguntaVisita.rawInsert(
          'INSERT OR REPLACE INTO preguntaVisita (id, tipoRespuestaA, tipoRespuestaB, tipoRespuestaC, esTexto, pregunta, cuestionarioHabitabilidad, etapaDeAvance, intervencionId, dateCreated)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            tipoRespuestaA,
            tipoRespuestaB,
            tipoRespuestaC,
            esTexto,
            pregunta,
            cuestionarioHabitabilidad,
            etapaDeAvance,
            intervencionId,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'PreguntaVisita id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PreguntaVisita id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PreguntaVisita Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PreguntaVisita>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<PreguntaVisita> preguntavisitas) async {
    final results = await _mnPreguntaVisita.rawInsertAll(
        'INSERT OR REPLACE INTO preguntaVisita (id, tipoRespuestaA, tipoRespuestaB, tipoRespuestaC, esTexto, pregunta, cuestionarioHabitabilidad, etapaDeAvance, intervencionId, dateCreated)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        preguntavisitas);
    return results;
  }

  /// Deletes PreguntaVisita

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PreguntaVisita invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await RespuestaVisita()
          .select()
          .preguntaVisitaId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnPreguntaVisita
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnPreguntaVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  PreguntaVisitaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PreguntaVisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PreguntaVisitaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PreguntaVisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    esTexto = esTexto ?? false;
    cuestionarioHabitabilidad = cuestionarioHabitabilidad ?? false;
    etapaDeAvance = etapaDeAvance ?? 0;
    dateCreated = dateCreated ?? DateTime.now();
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion preguntavisita

// region PreguntaVisitaField
class PreguntaVisitaField extends SearchCriteria {
  PreguntaVisitaField(this.preguntavisitaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  PreguntaVisitaFilterBuilder preguntavisitaFB;

  PreguntaVisitaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PreguntaVisitaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    preguntavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.EQuals, preguntavisitaFB._addedBlocks)
        : setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.NotEQuals, preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    preguntavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.EQualsOrNull, preguntavisitaFB._addedBlocks)
        : setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder isNull() {
    preguntavisitaFB._addedBlocks = setCriteria(
        0,
        preguntavisitaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      preguntavisitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          preguntavisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          preguntavisitaFB._addedBlocks);
      _waitingNot = '';
      preguntavisitaFB
              ._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
          preguntavisitaFB._addedBlocks.retVal;
    }
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      preguntavisitaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          preguntavisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          preguntavisitaFB._addedBlocks);
      _waitingNot = '';
      preguntavisitaFB
              ._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
          preguntavisitaFB._addedBlocks.retVal;
      preguntavisitaFB
              ._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
          preguntavisitaFB._addedBlocks.retVal;
    }
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      preguntavisitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          preguntavisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          preguntavisitaFB._addedBlocks);
      _waitingNot = '';
      preguntavisitaFB
              ._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
          preguntavisitaFB._addedBlocks.retVal;
    }
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      preguntavisitaFB._addedBlocks = setCriteria(
          pFirst,
          preguntavisitaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          preguntavisitaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        preguntavisitaFB._addedBlocks = setCriteria(
            pFirst,
            preguntavisitaFB.parameters,
            param,
            SqlSyntax.LessThan,
            preguntavisitaFB._addedBlocks);
      } else {
        preguntavisitaFB._addedBlocks = setCriteria(
            pFirst,
            preguntavisitaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            preguntavisitaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        preguntavisitaFB._addedBlocks = setCriteria(
            pLast,
            preguntavisitaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            preguntavisitaFB._addedBlocks);
      } else {
        preguntavisitaFB._addedBlocks = setCriteria(
            pLast,
            preguntavisitaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            preguntavisitaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    preguntavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.GreaterThan, preguntavisitaFB._addedBlocks)
        : setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    preguntavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.LessThan, preguntavisitaFB._addedBlocks)
        : setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    preguntavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, preguntavisitaFB._addedBlocks)
        : setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.LessThan, preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    preguntavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, preguntavisitaFB._addedBlocks)
        : setCriteria(pValue, preguntavisitaFB.parameters, param,
            SqlSyntax.GreaterThan, preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }

  PreguntaVisitaFilterBuilder inValues(dynamic pValue) {
    preguntavisitaFB._addedBlocks = setCriteria(
        pValue,
        preguntavisitaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        preguntavisitaFB._addedBlocks);
    _waitingNot = '';
    preguntavisitaFB._addedBlocks.needEndBlock![preguntavisitaFB._blockIndex] =
        preguntavisitaFB._addedBlocks.retVal;
    return preguntavisitaFB;
  }
}
// endregion PreguntaVisitaField

// region PreguntaVisitaFilterBuilder
class PreguntaVisitaFilterBuilder extends SearchCriteria {
  PreguntaVisitaFilterBuilder(PreguntaVisita obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  PreguntaVisita? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  PreguntaVisitaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PreguntaVisitaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PreguntaVisitaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PreguntaVisitaFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PreguntaVisitaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PreguntaVisitaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PreguntaVisitaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PreguntaVisitaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PreguntaVisitaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PreguntaVisitaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PreguntaVisitaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PreguntaVisitaField setField(
      PreguntaVisitaField? field, String colName, DbType dbtype) {
    return PreguntaVisitaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  PreguntaVisitaField? _id;
  PreguntaVisitaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  PreguntaVisitaField? _tipoRespuestaA;
  PreguntaVisitaField get tipoRespuestaA {
    return _tipoRespuestaA =
        setField(_tipoRespuestaA, 'tipoRespuestaA', DbType.text);
  }

  PreguntaVisitaField? _tipoRespuestaB;
  PreguntaVisitaField get tipoRespuestaB {
    return _tipoRespuestaB =
        setField(_tipoRespuestaB, 'tipoRespuestaB', DbType.text);
  }

  PreguntaVisitaField? _tipoRespuestaC;
  PreguntaVisitaField get tipoRespuestaC {
    return _tipoRespuestaC =
        setField(_tipoRespuestaC, 'tipoRespuestaC', DbType.text);
  }

  PreguntaVisitaField? _esTexto;
  PreguntaVisitaField get esTexto {
    return _esTexto = setField(_esTexto, 'esTexto', DbType.bool);
  }

  PreguntaVisitaField? _pregunta;
  PreguntaVisitaField get pregunta {
    return _pregunta = setField(_pregunta, 'pregunta', DbType.text);
  }

  PreguntaVisitaField? _cuestionarioHabitabilidad;
  PreguntaVisitaField get cuestionarioHabitabilidad {
    return _cuestionarioHabitabilidad = setField(
        _cuestionarioHabitabilidad, 'cuestionarioHabitabilidad', DbType.bool);
  }

  PreguntaVisitaField? _etapaDeAvance;
  PreguntaVisitaField get etapaDeAvance {
    return _etapaDeAvance =
        setField(_etapaDeAvance, 'etapaDeAvance', DbType.integer);
  }

  PreguntaVisitaField? _intervencionId;
  PreguntaVisitaField get intervencionId {
    return _intervencionId =
        setField(_intervencionId, 'intervencionId', DbType.integer);
  }

  PreguntaVisitaField? _dateCreated;
  PreguntaVisitaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (PreguntaVisita._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<PreguntaVisita> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (RespuestaVisita) according to DeleteRule.CASCADE
    final idListRespuestaVisitaBYpreguntaVisitaId = toListPrimaryKeySQL(false);
    final resRespuestaVisitaBYpreguntaVisitaId = await RespuestaVisita()
        .select()
        .where(
            'preguntaVisitaId IN (${idListRespuestaVisitaBYpreguntaVisitaId['sql']})',
            parameterValue: idListRespuestaVisitaBYpreguntaVisitaId['args'])
        .delete(hardDelete);
    if (!resRespuestaVisitaBYpreguntaVisitaId.success) {
      return resRespuestaVisitaBYpreguntaVisitaId;
    }

    if (PreguntaVisita._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnPreguntaVisita.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnPreguntaVisita.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from preguntaVisita ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnPreguntaVisita.updateBatch(qparams, values);
  }

  /// This method always returns [PreguntaVisita] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> PreguntaVisita?
  Future<PreguntaVisita?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnPreguntaVisita.toList(qparams);
    final data = await objFuture;
    PreguntaVisita? obj;
    if (data.isNotEmpty) {
      obj = PreguntaVisita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('preguntaVisita.plRespuestaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plRespuestaVisitas'))) {
          /*_loadedfields!.add('preguntaVisita.plRespuestaVisitas'); */ obj
                  .plRespuestaVisitas =
              obj.plRespuestaVisitas ??
                  await obj.getRespuestaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PreguntaVisita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> PreguntaVisita?
  Future<PreguntaVisita> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PreguntaVisita();
  }

  /// This method returns int. [PreguntaVisita]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? preguntavisitaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final preguntavisitasFuture = await _obj!._mnPreguntaVisita.toList(qparams);
    final int count = preguntavisitasFuture[0]['CNT'] as int;
    if (preguntavisitaCount != null) {
      preguntavisitaCount(count);
    }
    return count;
  }

  /// This method returns List<PreguntaVisita> [PreguntaVisita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PreguntaVisita>
  Future<List<PreguntaVisita>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PreguntaVisita> preguntavisitasData =
        await PreguntaVisita.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return preguntavisitasData;
  }

  /// This method returns Json String [PreguntaVisita]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PreguntaVisita]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PreguntaVisita]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnPreguntaVisita.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<PreguntaVisita>>
  Future<List<DropdownMenuItem<PreguntaVisita>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<PreguntaVisita>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final preguntavisitasFuture = _obj!._mnPreguntaVisita.toList(qparams);

    final data = await preguntavisitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<PreguntaVisita>> items = []
      ..add(DropdownMenuItem(
        value: PreguntaVisita(),
        child: Text('Select PreguntaVisita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: PreguntaVisita.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final preguntavisitasFuture = _obj!._mnPreguntaVisita.toList(qparams);

    final data = await preguntavisitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select PreguntaVisita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PreguntaVisita]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM preguntaVisita WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnPreguntaVisita.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PreguntaVisita]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnPreguntaVisita.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await PreguntaVisita.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnPreguntaVisita.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PreguntaVisitaFilterBuilder

// region PreguntaVisitaFields
class PreguntaVisitaFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fTipoRespuestaA;
  static TableField get tipoRespuestaA {
    return _fTipoRespuestaA = _fTipoRespuestaA ??
        SqlSyntax.setField(_fTipoRespuestaA, 'tipoRespuestaA', DbType.text);
  }

  static TableField? _fTipoRespuestaB;
  static TableField get tipoRespuestaB {
    return _fTipoRespuestaB = _fTipoRespuestaB ??
        SqlSyntax.setField(_fTipoRespuestaB, 'tipoRespuestaB', DbType.text);
  }

  static TableField? _fTipoRespuestaC;
  static TableField get tipoRespuestaC {
    return _fTipoRespuestaC = _fTipoRespuestaC ??
        SqlSyntax.setField(_fTipoRespuestaC, 'tipoRespuestaC', DbType.text);
  }

  static TableField? _fEsTexto;
  static TableField get esTexto {
    return _fEsTexto =
        _fEsTexto ?? SqlSyntax.setField(_fEsTexto, 'esTexto', DbType.bool);
  }

  static TableField? _fPregunta;
  static TableField get pregunta {
    return _fPregunta =
        _fPregunta ?? SqlSyntax.setField(_fPregunta, 'pregunta', DbType.text);
  }

  static TableField? _fCuestionarioHabitabilidad;
  static TableField get cuestionarioHabitabilidad {
    return _fCuestionarioHabitabilidad = _fCuestionarioHabitabilidad ??
        SqlSyntax.setField(_fCuestionarioHabitabilidad,
            'cuestionarioHabitabilidad', DbType.bool);
  }

  static TableField? _fEtapaDeAvance;
  static TableField get etapaDeAvance {
    return _fEtapaDeAvance = _fEtapaDeAvance ??
        SqlSyntax.setField(_fEtapaDeAvance, 'etapaDeAvance', DbType.integer);
  }

  static TableField? _fIntervencionId;
  static TableField get intervencionId {
    return _fIntervencionId = _fIntervencionId ??
        SqlSyntax.setField(_fIntervencionId, 'intervencionId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }
}
// endregion PreguntaVisitaFields

//region PreguntaVisitaManager
class PreguntaVisitaManager extends SqfEntityProvider {
  PreguntaVisitaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'preguntaVisita';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion PreguntaVisitaManager
// region RespuestaVisita
class RespuestaVisita extends TableBase {
  RespuestaVisita(
      {this.id,
      this.respuesta,
      this.puntaje,
      this.pgas,
      this.preguntaVisitaId,
      this.nroComponente,
      this.viviendaId,
      this.visitaId,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  RespuestaVisita.withFields(
      this.respuesta,
      this.puntaje,
      this.pgas,
      this.preguntaVisitaId,
      this.nroComponente,
      this.viviendaId,
      this.visitaId,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  RespuestaVisita.withId(
      this.id,
      this.respuesta,
      this.puntaje,
      this.pgas,
      this.preguntaVisitaId,
      this.nroComponente,
      this.viviendaId,
      this.visitaId,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  RespuestaVisita.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['respuesta'] != null) {
      respuesta = o['respuesta'].toString();
    }
    if (o['puntaje'] != null) {
      puntaje = double.tryParse(o['puntaje'].toString());
    }
    if (o['pgas'] != null) {
      pgas = o['pgas'].toString() == '1' || o['pgas'].toString() == 'true';
    }
    preguntaVisitaId = int.tryParse(o['preguntaVisitaId'].toString());

    if (o['nroComponente'] != null) {
      nroComponente = int.tryParse(o['nroComponente'].toString());
    }
    viviendaId = int.tryParse(o['viviendaId'].toString());

    visitaId = int.tryParse(o['visitaId'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plPreguntaVisita = o['preguntaVisita'] != null
        ? PreguntaVisita.fromMap(o['preguntaVisita'] as Map<String, dynamic>)
        : null;
    plVivienda = o['vivienda'] != null
        ? Vivienda.fromMap(o['vivienda'] as Map<String, dynamic>)
        : null;
    plVisita = o['visita'] != null
        ? Visita.fromMap(o['visita'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (RespuestaVisita)
  int? id;
  String? respuesta;
  double? puntaje;
  bool? pgas;
  int? preguntaVisitaId;
  int? nroComponente;
  int? viviendaId;
  int? visitaId;
  DateTime? dateCreated;
  bool? isDeleted;

  BoolResult? saveResult;
  // end FIELDS (RespuestaVisita)

// RELATIONSHIPS (RespuestaVisita)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPreguntaVisita', 'plField2'..]) or so on..
  PreguntaVisita? plPreguntaVisita;

  /// get PreguntaVisita By PreguntaVisitaId
  Future<PreguntaVisita?> getPreguntaVisita(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await PreguntaVisita().getById(preguntaVisitaId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVivienda', 'plField2'..]) or so on..
  Vivienda? plVivienda;

  /// get Vivienda By ViviendaId
  Future<Vivienda?> getVivienda(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Vivienda().getById(viviendaId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVisita', 'plField2'..]) or so on..
  Visita? plVisita;

  /// get Visita By VisitaId
  Future<Visita?> getVisita(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Visita().getById(visitaId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (RespuestaVisita)

  static const bool _softDeleteActivated = true;
  RespuestaVisitaManager? __mnRespuestaVisita;

  RespuestaVisitaManager get _mnRespuestaVisita {
    return __mnRespuestaVisita =
        __mnRespuestaVisita ?? RespuestaVisitaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['respuesta'] = respuesta;
    map['puntaje'] = puntaje;
    if (pgas != null) {
      map['pgas'] = forQuery ? (pgas! ? 1 : 0) : pgas;
    } else {
      map['pgas'] = null;
    }
    if (preguntaVisitaId != null) {
      map['preguntaVisitaId'] = forView
          ? plPreguntaVisita == null
              ? preguntaVisitaId
              : plPreguntaVisita!.tipoRespuestaA
          : preguntaVisitaId;
    } else {
      map['preguntaVisitaId'] = null;
    }
    map['nroComponente'] = nroComponente;
    if (viviendaId != null) {
      map['viviendaId'] = forView
          ? plVivienda == null
              ? viviendaId
              : plVivienda!.aliasRenabap
          : viviendaId;
    } else {
      map['viviendaId'] = null;
    }
    if (visitaId != null) {
      map['visitaId'] = forView
          ? plVisita == null
              ? visitaId
              : plVisita!.nombreRelevador
          : visitaId;
    } else {
      map['visitaId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['respuesta'] = respuesta;
    map['puntaje'] = puntaje;
    if (pgas != null) {
      map['pgas'] = forQuery ? (pgas! ? 1 : 0) : pgas;
    } else {
      map['pgas'] = null;
    }
    if (preguntaVisitaId != null) {
      map['preguntaVisitaId'] = forView
          ? plPreguntaVisita == null
              ? preguntaVisitaId
              : plPreguntaVisita!.tipoRespuestaA
          : preguntaVisitaId;
    } else {
      map['preguntaVisitaId'] = null;
    }
    map['nroComponente'] = nroComponente;
    if (viviendaId != null) {
      map['viviendaId'] = forView
          ? plVivienda == null
              ? viviendaId
              : plVivienda!.aliasRenabap
          : viviendaId;
    } else {
      map['viviendaId'] = null;
    }
    if (visitaId != null) {
      map['visitaId'] = forView
          ? plVisita == null
              ? visitaId
              : plVisita!.nombreRelevador
          : visitaId;
    } else {
      map['visitaId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [RespuestaVisita]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [RespuestaVisita]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      respuesta,
      puntaje,
      pgas,
      preguntaVisitaId,
      nroComponente,
      viviendaId,
      visitaId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      respuesta,
      puntaje,
      pgas,
      preguntaVisitaId,
      nroComponente,
      viviendaId,
      visitaId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<RespuestaVisita>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RespuestaVisita.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<RespuestaVisita>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <RespuestaVisita>[];
    try {
      objList = list
          .map((respuestavisita) =>
              RespuestaVisita.fromMap(respuestavisita as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RespuestaVisita.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<RespuestaVisita>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<RespuestaVisita> objList = <RespuestaVisita>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = RespuestaVisita.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('preguntaVisita.plPreguntaVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPreguntaVisita'))) {
          /*_loadedfields!.add('preguntaVisita.plPreguntaVisita');*/ obj
              .plPreguntaVisita = obj
                  .plPreguntaVisita ??
              await obj.getPreguntaVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('vivienda.plVivienda') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVivienda'))) {
          /*_loadedfields!.add('vivienda.plVivienda');*/ obj.plVivienda = obj
                  .plVivienda ??
              await obj.getVivienda(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('visita.plVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVisita'))) {
          /*_loadedfields!.add('visita.plVisita');*/ obj.plVisita = obj
                  .plVisita ??
              await obj.getVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns RespuestaVisita by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [RespuestaVisita] if exist, otherwise returns null
  Future<RespuestaVisita?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    RespuestaVisita? obj;
    final data = await _mnRespuestaVisita.getById([id]);
    if (data.length != 0) {
      obj = RespuestaVisita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('preguntaVisita.plPreguntaVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPreguntaVisita'))) {
          /*_loadedfields!.add('preguntaVisita.plPreguntaVisita');*/ obj
              .plPreguntaVisita = obj
                  .plPreguntaVisita ??
              await obj.getPreguntaVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('vivienda.plVivienda') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVivienda'))) {
          /*_loadedfields!.add('vivienda.plVivienda');*/ obj.plVivienda = obj
                  .plVivienda ??
              await obj.getVivienda(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('visita.plVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVisita'))) {
          /*_loadedfields!.add('visita.plVisita');*/ obj.plVisita = obj
                  .plVisita ??
              await obj.getVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (RespuestaVisita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRespuestaVisita.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRespuestaVisita.update(this);
    }

    return id;
  }

  /// Saves the (RespuestaVisita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRespuestaVisita.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRespuestaVisita.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs RespuestaVisita. Returns a new Primary Key value of RespuestaVisita

  /// <returns>Returns a new Primary Key value of RespuestaVisita
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<RespuestaVisita> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<RespuestaVisita> respuestavisitas) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in respuestavisitas) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
      for (int i = 0; i < respuestavisitas.length; i++) {
        if (respuestavisitas[i].id == null) {
          respuestavisitas[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRespuestaVisita.rawInsert(
          'INSERT OR REPLACE INTO respuestaVisita (id, respuesta, puntaje, pgas, preguntaVisitaId, nroComponente, viviendaId, visitaId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            respuesta,
            puntaje,
            pgas,
            preguntaVisitaId,
            nroComponente,
            viviendaId,
            visitaId,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'RespuestaVisita id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'RespuestaVisita id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'RespuestaVisita Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<RespuestaVisita>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<RespuestaVisita> respuestavisitas) async {
    final results = await _mnRespuestaVisita.rawInsertAll(
        'INSERT OR REPLACE INTO respuestaVisita (id, respuesta, puntaje, pgas, preguntaVisitaId, nroComponente, viviendaId, visitaId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        respuestavisitas);
    return results;
  }

  /// Deletes RespuestaVisita

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete RespuestaVisita invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnRespuestaVisita
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnRespuestaVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover RespuestaVisita>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover RespuestaVisita invoked (id=$id)');
    {
      return _mnRespuestaVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  RespuestaVisitaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RespuestaVisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  RespuestaVisitaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RespuestaVisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    puntaje = puntaje ?? -1;
    pgas = pgas ?? false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion respuestavisita

// region RespuestaVisitaField
class RespuestaVisitaField extends SearchCriteria {
  RespuestaVisitaField(this.respuestavisitaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  RespuestaVisitaFilterBuilder respuestavisitaFB;

  RespuestaVisitaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  RespuestaVisitaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    respuestavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.EQuals, respuestavisitaFB._addedBlocks)
        : setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.NotEQuals, respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    respuestavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.EQualsOrNull, respuestavisitaFB._addedBlocks)
        : setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder isNull() {
    respuestavisitaFB._addedBlocks = setCriteria(
        0,
        respuestavisitaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      respuestavisitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          respuestavisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          respuestavisitaFB._addedBlocks);
      _waitingNot = '';
      respuestavisitaFB
              ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
          respuestavisitaFB._addedBlocks.retVal;
    }
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      respuestavisitaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          respuestavisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          respuestavisitaFB._addedBlocks);
      _waitingNot = '';
      respuestavisitaFB
              ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
          respuestavisitaFB._addedBlocks.retVal;
      respuestavisitaFB
              ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
          respuestavisitaFB._addedBlocks.retVal;
    }
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      respuestavisitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          respuestavisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          respuestavisitaFB._addedBlocks);
      _waitingNot = '';
      respuestavisitaFB
              ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
          respuestavisitaFB._addedBlocks.retVal;
    }
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      respuestavisitaFB._addedBlocks = setCriteria(
          pFirst,
          respuestavisitaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          respuestavisitaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        respuestavisitaFB._addedBlocks = setCriteria(
            pFirst,
            respuestavisitaFB.parameters,
            param,
            SqlSyntax.LessThan,
            respuestavisitaFB._addedBlocks);
      } else {
        respuestavisitaFB._addedBlocks = setCriteria(
            pFirst,
            respuestavisitaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            respuestavisitaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        respuestavisitaFB._addedBlocks = setCriteria(
            pLast,
            respuestavisitaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            respuestavisitaFB._addedBlocks);
      } else {
        respuestavisitaFB._addedBlocks = setCriteria(
            pLast,
            respuestavisitaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            respuestavisitaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    respuestavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.GreaterThan, respuestavisitaFB._addedBlocks)
        : setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    respuestavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.LessThan, respuestavisitaFB._addedBlocks)
        : setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    respuestavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, respuestavisitaFB._addedBlocks)
        : setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.LessThan, respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    respuestavisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, respuestavisitaFB._addedBlocks)
        : setCriteria(pValue, respuestavisitaFB.parameters, param,
            SqlSyntax.GreaterThan, respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }

  RespuestaVisitaFilterBuilder inValues(dynamic pValue) {
    respuestavisitaFB._addedBlocks = setCriteria(
        pValue,
        respuestavisitaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        respuestavisitaFB._addedBlocks);
    _waitingNot = '';
    respuestavisitaFB
            ._addedBlocks.needEndBlock![respuestavisitaFB._blockIndex] =
        respuestavisitaFB._addedBlocks.retVal;
    return respuestavisitaFB;
  }
}
// endregion RespuestaVisitaField

// region RespuestaVisitaFilterBuilder
class RespuestaVisitaFilterBuilder extends SearchCriteria {
  RespuestaVisitaFilterBuilder(RespuestaVisita obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  RespuestaVisita? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  RespuestaVisitaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  RespuestaVisitaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  RespuestaVisitaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  RespuestaVisitaFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  RespuestaVisitaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  RespuestaVisitaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  RespuestaVisitaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  RespuestaVisitaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  RespuestaVisitaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  RespuestaVisitaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  RespuestaVisitaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  RespuestaVisitaField setField(
      RespuestaVisitaField? field, String colName, DbType dbtype) {
    return RespuestaVisitaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  RespuestaVisitaField? _id;
  RespuestaVisitaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  RespuestaVisitaField? _respuesta;
  RespuestaVisitaField get respuesta {
    return _respuesta = setField(_respuesta, 'respuesta', DbType.text);
  }

  RespuestaVisitaField? _puntaje;
  RespuestaVisitaField get puntaje {
    return _puntaje = setField(_puntaje, 'puntaje', DbType.real);
  }

  RespuestaVisitaField? _pgas;
  RespuestaVisitaField get pgas {
    return _pgas = setField(_pgas, 'pgas', DbType.bool);
  }

  RespuestaVisitaField? _preguntaVisitaId;
  RespuestaVisitaField get preguntaVisitaId {
    return _preguntaVisitaId =
        setField(_preguntaVisitaId, 'preguntaVisitaId', DbType.integer);
  }

  RespuestaVisitaField? _nroComponente;
  RespuestaVisitaField get nroComponente {
    return _nroComponente =
        setField(_nroComponente, 'nroComponente', DbType.integer);
  }

  RespuestaVisitaField? _viviendaId;
  RespuestaVisitaField get viviendaId {
    return _viviendaId = setField(_viviendaId, 'viviendaId', DbType.integer);
  }

  RespuestaVisitaField? _visitaId;
  RespuestaVisitaField get visitaId {
    return _visitaId = setField(_visitaId, 'visitaId', DbType.integer);
  }

  RespuestaVisitaField? _dateCreated;
  RespuestaVisitaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  RespuestaVisitaField? _isDeleted;
  RespuestaVisitaField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (RespuestaVisita._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<RespuestaVisita> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (RespuestaVisita._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnRespuestaVisita.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnRespuestaVisita.delete(qparams);
    }
    return r;
  }

  /// Recover List<RespuestaVisita> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover RespuestaVisita bulk invoked');
    return _obj!._mnRespuestaVisita.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from respuestaVisita ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnRespuestaVisita.updateBatch(qparams, values);
  }

  /// This method always returns [RespuestaVisita] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> RespuestaVisita?
  Future<RespuestaVisita?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnRespuestaVisita.toList(qparams);
    final data = await objFuture;
    RespuestaVisita? obj;
    if (data.isNotEmpty) {
      obj = RespuestaVisita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('preguntaVisita.plPreguntaVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPreguntaVisita'))) {
          /*_loadedfields!.add('preguntaVisita.plPreguntaVisita');*/ obj
              .plPreguntaVisita = obj
                  .plPreguntaVisita ??
              await obj.getPreguntaVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('vivienda.plVivienda') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVivienda'))) {
          /*_loadedfields!.add('vivienda.plVivienda');*/ obj.plVivienda = obj
                  .plVivienda ??
              await obj.getVivienda(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('visita.plVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVisita'))) {
          /*_loadedfields!.add('visita.plVisita');*/ obj.plVisita = obj
                  .plVisita ??
              await obj.getVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [RespuestaVisita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> RespuestaVisita?
  Future<RespuestaVisita> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        RespuestaVisita();
  }

  /// This method returns int. [RespuestaVisita]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? respuestavisitaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final respuestavisitasFuture =
        await _obj!._mnRespuestaVisita.toList(qparams);
    final int count = respuestavisitasFuture[0]['CNT'] as int;
    if (respuestavisitaCount != null) {
      respuestavisitaCount(count);
    }
    return count;
  }

  /// This method returns List<RespuestaVisita> [RespuestaVisita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<RespuestaVisita>
  Future<List<RespuestaVisita>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<RespuestaVisita> respuestavisitasData =
        await RespuestaVisita.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return respuestavisitasData;
  }

  /// This method returns Json String [RespuestaVisita]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [RespuestaVisita]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [RespuestaVisita]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnRespuestaVisita.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<RespuestaVisita>>
  Future<List<DropdownMenuItem<RespuestaVisita>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<RespuestaVisita>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final respuestavisitasFuture = _obj!._mnRespuestaVisita.toList(qparams);

    final data = await respuestavisitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<RespuestaVisita>> items = []
      ..add(DropdownMenuItem(
        value: RespuestaVisita(),
        child: Text('Select RespuestaVisita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: RespuestaVisita.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final respuestavisitasFuture = _obj!._mnRespuestaVisita.toList(qparams);

    final data = await respuestavisitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select RespuestaVisita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [RespuestaVisita]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM respuestaVisita WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnRespuestaVisita.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [RespuestaVisita]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnRespuestaVisita.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await RespuestaVisita.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnRespuestaVisita.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RespuestaVisitaFilterBuilder

// region RespuestaVisitaFields
class RespuestaVisitaFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fRespuesta;
  static TableField get respuesta {
    return _fRespuesta = _fRespuesta ??
        SqlSyntax.setField(_fRespuesta, 'respuesta', DbType.text);
  }

  static TableField? _fPuntaje;
  static TableField get puntaje {
    return _fPuntaje =
        _fPuntaje ?? SqlSyntax.setField(_fPuntaje, 'puntaje', DbType.real);
  }

  static TableField? _fPgas;
  static TableField get pgas {
    return _fPgas = _fPgas ?? SqlSyntax.setField(_fPgas, 'pgas', DbType.bool);
  }

  static TableField? _fPreguntaVisitaId;
  static TableField get preguntaVisitaId {
    return _fPreguntaVisitaId = _fPreguntaVisitaId ??
        SqlSyntax.setField(
            _fPreguntaVisitaId, 'preguntaVisitaId', DbType.integer);
  }

  static TableField? _fNroComponente;
  static TableField get nroComponente {
    return _fNroComponente = _fNroComponente ??
        SqlSyntax.setField(_fNroComponente, 'nroComponente', DbType.integer);
  }

  static TableField? _fViviendaId;
  static TableField get viviendaId {
    return _fViviendaId = _fViviendaId ??
        SqlSyntax.setField(_fViviendaId, 'viviendaId', DbType.integer);
  }

  static TableField? _fVisitaId;
  static TableField get visitaId {
    return _fVisitaId = _fVisitaId ??
        SqlSyntax.setField(_fVisitaId, 'visitaId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion RespuestaVisitaFields

//region RespuestaVisitaManager
class RespuestaVisitaManager extends SqfEntityProvider {
  RespuestaVisitaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'respuestaVisita';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion RespuestaVisitaManager
// region Intervencion
class Intervencion extends TableBase {
  Intervencion(
      {this.id, this.nombre, this.esPgas, this.dateCreated, this.isDeleted}) {
    _setDefaultValues();
  }
  Intervencion.withFields(
      this.id, this.nombre, this.esPgas, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Intervencion.withId(
      this.id, this.nombre, this.esPgas, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Intervencion.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['nombre'] != null) {
      nombre = o['nombre'].toString();
    }
    if (o['esPgas'] != null) {
      esPgas =
          o['esPgas'].toString() == '1' || o['esPgas'].toString() == 'true';
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    isSaved = true;
  }
  // FIELDS (Intervencion)
  int? id;
  String? nombre;
  bool? esPgas;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Intervencion)

// COLLECTIONS & VIRTUALS (Intervencion)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPreguntaVisitas', 'plField2'..]) or so on..
  List<PreguntaVisita>? plPreguntaVisitas;

  /// get PreguntaVisita(s) filtered by id=intervencionId
  PreguntaVisitaFilterBuilder? getPreguntaVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return PreguntaVisita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .intervencionId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFotoVisitas', 'plField2'..]) or so on..
  List<FotoVisita>? plFotoVisitas;

  /// get FotoVisita(s) filtered by id=intervencionId
  FotoVisitaFilterBuilder? getFotoVisitas(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return FotoVisita()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .intervencionId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plObra_intervencions', 'plField2'..]) or so on..
  List<Obra_intervencion>? plObra_intervencions;

  /// get Obra_intervencion(s) filtered by id=intervencionId
  Obra_intervencionFilterBuilder? getObra_intervencions(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Obra_intervencion()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .intervencionId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Intervencion)

  static const bool _softDeleteActivated = true;
  IntervencionManager? __mnIntervencion;

  IntervencionManager get _mnIntervencion {
    return __mnIntervencion = __mnIntervencion ?? IntervencionManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['nombre'] = nombre;
    if (esPgas != null) {
      map['esPgas'] = forQuery ? (esPgas! ? 1 : 0) : esPgas;
    } else {
      map['esPgas'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['nombre'] = nombre;
    if (esPgas != null) {
      map['esPgas'] = forQuery ? (esPgas! ? 1 : 0) : esPgas;
    } else {
      map['esPgas'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (Intervencion)
    if (!forQuery) {
      map['PreguntaVisitas'] = await getPreguntaVisitas()!.toMapList();
    }
    if (!forQuery) {
      map['FotoVisitas'] = await getFotoVisitas()!.toMapList();
    }
    if (!forQuery) {
      map['Obra_intervencions'] = await getObra_intervencions()!.toMapList();
    }
// END COLLECTIONS (Intervencion)

    return map;
  }

  /// This method returns Json String [Intervencion]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Intervencion]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      nombre,
      esPgas,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      nombre,
      esPgas,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Intervencion>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Intervencion.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Intervencion>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Intervencion>[];
    try {
      objList = list
          .map((intervencion) =>
              Intervencion.fromMap(intervencion as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Intervencion.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Intervencion>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Intervencion> objList = <Intervencion>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Intervencion.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plPreguntaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPreguntaVisitas'))) {
          /*_loadedfields!.add('intervencion.plPreguntaVisitas'); */ obj
                  .plPreguntaVisitas =
              obj.plPreguntaVisitas ??
                  await obj.getPreguntaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plFotoVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoVisitas'))) {
          /*_loadedfields!.add('intervencion.plFotoVisitas'); */ obj
                  .plFotoVisitas =
              obj.plFotoVisitas ??
                  await obj.getFotoVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plObra_intervencions') && */ (preloadFields ==
                null ||
            preloadFields.contains('plObra_intervencions'))) {
          /*_loadedfields!.add('intervencion.plObra_intervencions'); */ obj
                  .plObra_intervencions =
              obj.plObra_intervencions ??
                  await obj.getObra_intervencions()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Intervencion by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Intervencion] if exist, otherwise returns null
  Future<Intervencion?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Intervencion? obj;
    final data = await _mnIntervencion.getById([id]);
    if (data.length != 0) {
      obj = Intervencion.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plPreguntaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPreguntaVisitas'))) {
          /*_loadedfields!.add('intervencion.plPreguntaVisitas'); */ obj
                  .plPreguntaVisitas =
              obj.plPreguntaVisitas ??
                  await obj.getPreguntaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plFotoVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoVisitas'))) {
          /*_loadedfields!.add('intervencion.plFotoVisitas'); */ obj
                  .plFotoVisitas =
              obj.plFotoVisitas ??
                  await obj.getFotoVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plObra_intervencions') && */ (preloadFields ==
                null ||
            preloadFields.contains('plObra_intervencions'))) {
          /*_loadedfields!.add('intervencion.plObra_intervencions'); */ obj
                  .plObra_intervencions =
              obj.plObra_intervencions ??
                  await obj.getObra_intervencions()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Intervencion) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnIntervencion.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIntervencion.update(this);
    }

    return id;
  }

  /// Saves the (Intervencion) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0 || !isSaved!) {
      await _mnIntervencion.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIntervencion.updateOrThrow(this);
    }

    return id;
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<Intervencion> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Intervencion> intervencions) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in intervencions) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnIntervencion.rawInsert(
          'INSERT OR REPLACE INTO intervencion (id, nombre, esPgas, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
          [
            id,
            nombre,
            esPgas,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Intervencion id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Intervencion id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Intervencion Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Intervencion>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Intervencion> intervencions) async {
    final results = await _mnIntervencion.rawInsertAll(
        'INSERT OR REPLACE INTO intervencion (id, nombre, esPgas, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
        intervencions);
    return results;
  }

  /// Deletes Intervencion

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Intervencion invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await PreguntaVisita()
          .select()
          .intervencionId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await FotoVisita()
          .select()
          .intervencionId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await Obra_intervencion()
          .select()
          .intervencionId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnIntervencion
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnIntervencion.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Intervencion>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Intervencion invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await FotoVisita()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .intervencionId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    if (recoverChilds) {
      result = await Obra_intervencion()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .intervencionId
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnIntervencion.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  IntervencionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return IntervencionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  IntervencionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return IntervencionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    esPgas = esPgas ?? false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion intervencion

// region IntervencionField
class IntervencionField extends SearchCriteria {
  IntervencionField(this.intervencionFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  IntervencionFilterBuilder intervencionFB;

  IntervencionField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  IntervencionFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.EQuals, intervencionFB._addedBlocks)
        : setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.NotEQuals, intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.EQualsOrNull, intervencionFB._addedBlocks)
        : setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder isNull() {
    intervencionFB._addedBlocks = setCriteria(
        0,
        intervencionFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      intervencionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          intervencionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          intervencionFB._addedBlocks);
      _waitingNot = '';
      intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
          intervencionFB._addedBlocks.retVal;
    }
    return intervencionFB;
  }

  IntervencionFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      intervencionFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          intervencionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          intervencionFB._addedBlocks);
      _waitingNot = '';
      intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
          intervencionFB._addedBlocks.retVal;
      intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
          intervencionFB._addedBlocks.retVal;
    }
    return intervencionFB;
  }

  IntervencionFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      intervencionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          intervencionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          intervencionFB._addedBlocks);
      _waitingNot = '';
      intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
          intervencionFB._addedBlocks.retVal;
    }
    return intervencionFB;
  }

  IntervencionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      intervencionFB._addedBlocks = setCriteria(
          pFirst,
          intervencionFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          intervencionFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        intervencionFB._addedBlocks = setCriteria(
            pFirst,
            intervencionFB.parameters,
            param,
            SqlSyntax.LessThan,
            intervencionFB._addedBlocks);
      } else {
        intervencionFB._addedBlocks = setCriteria(
            pFirst,
            intervencionFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            intervencionFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        intervencionFB._addedBlocks = setCriteria(
            pLast,
            intervencionFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            intervencionFB._addedBlocks);
      } else {
        intervencionFB._addedBlocks = setCriteria(
            pLast,
            intervencionFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            intervencionFB._addedBlocks);
      }
    }
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.GreaterThan, intervencionFB._addedBlocks)
        : setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.LessThan, intervencionFB._addedBlocks)
        : setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, intervencionFB._addedBlocks)
        : setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.LessThan, intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, intervencionFB._addedBlocks)
        : setCriteria(pValue, intervencionFB.parameters, param,
            SqlSyntax.GreaterThan, intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }

  IntervencionFilterBuilder inValues(dynamic pValue) {
    intervencionFB._addedBlocks = setCriteria(
        pValue,
        intervencionFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        intervencionFB._addedBlocks);
    _waitingNot = '';
    intervencionFB._addedBlocks.needEndBlock![intervencionFB._blockIndex] =
        intervencionFB._addedBlocks.retVal;
    return intervencionFB;
  }
}
// endregion IntervencionField

// region IntervencionFilterBuilder
class IntervencionFilterBuilder extends SearchCriteria {
  IntervencionFilterBuilder(Intervencion obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Intervencion? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  IntervencionFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  IntervencionFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  IntervencionFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  IntervencionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  IntervencionFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  IntervencionFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  IntervencionFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IntervencionFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IntervencionFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  IntervencionFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  IntervencionFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  IntervencionField setField(
      IntervencionField? field, String colName, DbType dbtype) {
    return IntervencionField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  IntervencionField? _id;
  IntervencionField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  IntervencionField? _nombre;
  IntervencionField get nombre {
    return _nombre = setField(_nombre, 'nombre', DbType.text);
  }

  IntervencionField? _esPgas;
  IntervencionField get esPgas {
    return _esPgas = setField(_esPgas, 'esPgas', DbType.bool);
  }

  IntervencionField? _dateCreated;
  IntervencionField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  IntervencionField? _isDeleted;
  IntervencionField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Intervencion._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Intervencion> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (PreguntaVisita) according to DeleteRule.CASCADE
    final idListPreguntaVisitaBYintervencionId = toListPrimaryKeySQL(false);
    final resPreguntaVisitaBYintervencionId = await PreguntaVisita()
        .select()
        .where(
            'intervencionId IN (${idListPreguntaVisitaBYintervencionId['sql']})',
            parameterValue: idListPreguntaVisitaBYintervencionId['args'])
        .delete(hardDelete);
    if (!resPreguntaVisitaBYintervencionId.success) {
      return resPreguntaVisitaBYintervencionId;
    }
// Delete sub records where in (FotoVisita) according to DeleteRule.CASCADE
    final idListFotoVisitaBYintervencionId = toListPrimaryKeySQL(false);
    final resFotoVisitaBYintervencionId = await FotoVisita()
        .select()
        .where('intervencionId IN (${idListFotoVisitaBYintervencionId['sql']})',
            parameterValue: idListFotoVisitaBYintervencionId['args'])
        .delete(hardDelete);
    if (!resFotoVisitaBYintervencionId.success) {
      return resFotoVisitaBYintervencionId;
    }
// Delete sub records where in (Obra_intervencion) according to DeleteRule.CASCADE
    final idListObra_intervencionBYintervencionId = toListPrimaryKeySQL(false);
    final resObra_intervencionBYintervencionId = await Obra_intervencion()
        .select()
        .where(
            'intervencionId IN (${idListObra_intervencionBYintervencionId['sql']})',
            parameterValue: idListObra_intervencionBYintervencionId['args'])
        .delete(hardDelete);
    if (!resObra_intervencionBYintervencionId.success) {
      return resObra_intervencionBYintervencionId;
    }

    if (Intervencion._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnIntervencion.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnIntervencion.delete(qparams);
    }
    return r;
  }

  /// Recover List<Intervencion> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover Intervencion bulk invoked');
    // Recover sub records where in (FotoVisita) according to DeleteRule.CASCADE
    final idListFotoVisitaBYintervencionId = toListPrimaryKeySQL(false);
    final resFotoVisitaBYintervencionId = await FotoVisita()
        .select()
        .where('intervencionId IN (${idListFotoVisitaBYintervencionId['sql']})',
            parameterValue: idListFotoVisitaBYintervencionId['args'])
        .update({'isDeleted': 0});
    if (!resFotoVisitaBYintervencionId.success) {
      return resFotoVisitaBYintervencionId;
    }
// Recover sub records where in (Obra_intervencion) according to DeleteRule.CASCADE
    final idListObra_intervencionBYintervencionId = toListPrimaryKeySQL(false);
    final resObra_intervencionBYintervencionId = await Obra_intervencion()
        .select()
        .where(
            'intervencionId IN (${idListObra_intervencionBYintervencionId['sql']})',
            parameterValue: idListObra_intervencionBYintervencionId['args'])
        .update({'isDeleted': 0});
    if (!resObra_intervencionBYintervencionId.success) {
      return resObra_intervencionBYintervencionId;
    }
    return _obj!._mnIntervencion.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from intervencion ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnIntervencion.updateBatch(qparams, values);
  }

  /// This method always returns [Intervencion] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Intervencion?
  Future<Intervencion?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnIntervencion.toList(qparams);
    final data = await objFuture;
    Intervencion? obj;
    if (data.isNotEmpty) {
      obj = Intervencion.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plPreguntaVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPreguntaVisitas'))) {
          /*_loadedfields!.add('intervencion.plPreguntaVisitas'); */ obj
                  .plPreguntaVisitas =
              obj.plPreguntaVisitas ??
                  await obj.getPreguntaVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plFotoVisitas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plFotoVisitas'))) {
          /*_loadedfields!.add('intervencion.plFotoVisitas'); */ obj
                  .plFotoVisitas =
              obj.plFotoVisitas ??
                  await obj.getFotoVisitas()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plObra_intervencions') && */ (preloadFields ==
                null ||
            preloadFields.contains('plObra_intervencions'))) {
          /*_loadedfields!.add('intervencion.plObra_intervencions'); */ obj
                  .plObra_intervencions =
              obj.plObra_intervencions ??
                  await obj.getObra_intervencions()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Intervencion]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Intervencion?
  Future<Intervencion> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Intervencion();
  }

  /// This method returns int. [Intervencion]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? intervencionCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final intervencionsFuture = await _obj!._mnIntervencion.toList(qparams);
    final int count = intervencionsFuture[0]['CNT'] as int;
    if (intervencionCount != null) {
      intervencionCount(count);
    }
    return count;
  }

  /// This method returns List<Intervencion> [Intervencion]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Intervencion>
  Future<List<Intervencion>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Intervencion> intervencionsData = await Intervencion.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return intervencionsData;
  }

  /// This method returns Json String [Intervencion]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Intervencion]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Intervencion]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnIntervencion.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Intervencion>>
  Future<List<DropdownMenuItem<Intervencion>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Intervencion>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final intervencionsFuture = _obj!._mnIntervencion.toList(qparams);

    final data = await intervencionsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Intervencion>> items = []..add(DropdownMenuItem(
        value: Intervencion(),
        child: Text('Select Intervencion'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Intervencion.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final intervencionsFuture = _obj!._mnIntervencion.toList(qparams);

    final data = await intervencionsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Intervencion'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Intervencion]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM intervencion WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnIntervencion.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Intervencion]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnIntervencion.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Intervencion.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnIntervencion.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IntervencionFilterBuilder

// region IntervencionFields
class IntervencionFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fNombre;
  static TableField get nombre {
    return _fNombre =
        _fNombre ?? SqlSyntax.setField(_fNombre, 'nombre', DbType.text);
  }

  static TableField? _fEsPgas;
  static TableField get esPgas {
    return _fEsPgas =
        _fEsPgas ?? SqlSyntax.setField(_fEsPgas, 'esPgas', DbType.bool);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion IntervencionFields

//region IntervencionManager
class IntervencionManager extends SqfEntityProvider {
  IntervencionManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'intervencion';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion IntervencionManager
// region FotoVisita
class FotoVisita extends TableBase {
  FotoVisita(
      {this.id,
      this.imagen,
      this.visitaId,
      this.intervencionId,
      this.nroComponente,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  FotoVisita.withFields(this.imagen, this.visitaId, this.intervencionId,
      this.nroComponente, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  FotoVisita.withId(this.id, this.imagen, this.visitaId, this.intervencionId,
      this.nroComponente, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FotoVisita.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['imagen'] != null) {
      imagen = o['imagen'] as Uint8List;
    }
    visitaId = int.tryParse(o['visitaId'].toString());

    intervencionId = int.tryParse(o['intervencionId'].toString());

    if (o['nroComponente'] != null) {
      nroComponente = int.tryParse(o['nroComponente'].toString());
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plVisita = o['visita'] != null
        ? Visita.fromMap(o['visita'] as Map<String, dynamic>)
        : null;
    plIntervencion = o['intervencion'] != null
        ? Intervencion.fromMap(o['intervencion'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (FotoVisita)
  int? id;
  Uint8List? imagen;
  int? visitaId;
  int? intervencionId;
  int? nroComponente;
  DateTime? dateCreated;
  bool? isDeleted;

  BoolResult? saveResult;
  // end FIELDS (FotoVisita)

// RELATIONSHIPS (FotoVisita)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVisita', 'plField2'..]) or so on..
  Visita? plVisita;

  /// get Visita By VisitaId
  Future<Visita?> getVisita(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Visita().getById(visitaId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plIntervencion', 'plField2'..]) or so on..
  Intervencion? plIntervencion;

  /// get Intervencion By IntervencionId
  Future<Intervencion?> getIntervencion(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Intervencion().getById(intervencionId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (FotoVisita)

  static const bool _softDeleteActivated = true;
  FotoVisitaManager? __mnFotoVisita;

  FotoVisitaManager get _mnFotoVisita {
    return __mnFotoVisita = __mnFotoVisita ?? FotoVisitaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['imagen'] = imagen;
    if (visitaId != null) {
      map['visitaId'] = forView
          ? plVisita == null
              ? visitaId
              : plVisita!.nombreRelevador
          : visitaId;
    } else {
      map['visitaId'] = null;
    }
    if (intervencionId != null) {
      map['intervencionId'] = forView
          ? plIntervencion == null
              ? intervencionId
              : plIntervencion!.nombre
          : intervencionId;
    } else {
      map['intervencionId'] = null;
    }
    map['nroComponente'] = nroComponente;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['imagen'] = imagen;
    if (visitaId != null) {
      map['visitaId'] = forView
          ? plVisita == null
              ? visitaId
              : plVisita!.nombreRelevador
          : visitaId;
    } else {
      map['visitaId'] = null;
    }
    if (intervencionId != null) {
      map['intervencionId'] = forView
          ? plIntervencion == null
              ? intervencionId
              : plIntervencion!.nombre
          : intervencionId;
    } else {
      map['intervencionId'] = null;
    }
    map['nroComponente'] = nroComponente;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [FotoVisita]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FotoVisita]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      imagen,
      visitaId,
      intervencionId,
      nroComponente,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      imagen,
      visitaId,
      intervencionId,
      nroComponente,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<FotoVisita>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FotoVisita.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FotoVisita>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FotoVisita>[];
    try {
      objList = list
          .map((fotovisita) =>
              FotoVisita.fromMap(fotovisita as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FotoVisita.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FotoVisita>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FotoVisita> objList = <FotoVisita>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FotoVisita.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('visita.plVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVisita'))) {
          /*_loadedfields!.add('visita.plVisita');*/ obj.plVisita = obj
                  .plVisita ??
              await obj.getVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns FotoVisita by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [FotoVisita] if exist, otherwise returns null
  Future<FotoVisita?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    FotoVisita? obj;
    final data = await _mnFotoVisita.getById([id]);
    if (data.length != 0) {
      obj = FotoVisita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('visita.plVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVisita'))) {
          /*_loadedfields!.add('visita.plVisita');*/ obj.plVisita = obj
                  .plVisita ??
              await obj.getVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FotoVisita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnFotoVisita.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFotoVisita.update(this);
    }

    return id;
  }

  /// Saves the (FotoVisita) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnFotoVisita.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFotoVisita.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs FotoVisita. Returns a new Primary Key value of FotoVisita

  /// <returns>Returns a new Primary Key value of FotoVisita
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<FotoVisita> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<FotoVisita> fotovisitas) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in fotovisitas) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
      for (int i = 0; i < fotovisitas.length; i++) {
        if (fotovisitas[i].id == null) {
          fotovisitas[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFotoVisita.rawInsert(
          'INSERT OR REPLACE INTO fotoVisita (id, imagen, visitaId, intervencionId, nroComponente, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            imagen,
            visitaId,
            intervencionId,
            nroComponente,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'FotoVisita id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'FotoVisita id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FotoVisita Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<FotoVisita>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<FotoVisita> fotovisitas) async {
    final results = await _mnFotoVisita.rawInsertAll(
        'INSERT OR REPLACE INTO fotoVisita (id, imagen, visitaId, intervencionId, nroComponente, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        fotovisitas);
    return results;
  }

  /// Deletes FotoVisita

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete FotoVisita invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnFotoVisita
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnFotoVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover FotoVisita>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover FotoVisita invoked (id=$id)');
    {
      return _mnFotoVisita.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  FotoVisitaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FotoVisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  FotoVisitaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FotoVisitaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion fotovisita

// region FotoVisitaField
class FotoVisitaField extends SearchCriteria {
  FotoVisitaField(this.fotovisitaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  FotoVisitaFilterBuilder fotovisitaFB;

  FotoVisitaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  FotoVisitaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    fotovisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotovisitaFB.parameters, param, SqlSyntax.EQuals,
            fotovisitaFB._addedBlocks)
        : setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.NotEQuals, fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    fotovisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.EQualsOrNull, fotovisitaFB._addedBlocks)
        : setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder isNull() {
    fotovisitaFB._addedBlocks = setCriteria(
        0,
        fotovisitaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      fotovisitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          fotovisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotovisitaFB._addedBlocks);
      _waitingNot = '';
      fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
          fotovisitaFB._addedBlocks.retVal;
    }
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      fotovisitaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          fotovisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotovisitaFB._addedBlocks);
      _waitingNot = '';
      fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
          fotovisitaFB._addedBlocks.retVal;
      fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
          fotovisitaFB._addedBlocks.retVal;
    }
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      fotovisitaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          fotovisitaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotovisitaFB._addedBlocks);
      _waitingNot = '';
      fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
          fotovisitaFB._addedBlocks.retVal;
    }
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      fotovisitaFB._addedBlocks = setCriteria(
          pFirst,
          fotovisitaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotovisitaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        fotovisitaFB._addedBlocks = setCriteria(pFirst, fotovisitaFB.parameters,
            param, SqlSyntax.LessThan, fotovisitaFB._addedBlocks);
      } else {
        fotovisitaFB._addedBlocks = setCriteria(pFirst, fotovisitaFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, fotovisitaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        fotovisitaFB._addedBlocks = setCriteria(pLast, fotovisitaFB.parameters,
            param, SqlSyntax.GreaterThan, fotovisitaFB._addedBlocks);
      } else {
        fotovisitaFB._addedBlocks = setCriteria(pLast, fotovisitaFB.parameters,
            param, SqlSyntax.LessThanOrEquals, fotovisitaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    fotovisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.GreaterThan, fotovisitaFB._addedBlocks)
        : setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    fotovisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.LessThan, fotovisitaFB._addedBlocks)
        : setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    fotovisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fotovisitaFB._addedBlocks)
        : setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.LessThan, fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    fotovisitaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fotovisitaFB._addedBlocks)
        : setCriteria(pValue, fotovisitaFB.parameters, param,
            SqlSyntax.GreaterThan, fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }

  FotoVisitaFilterBuilder inValues(dynamic pValue) {
    fotovisitaFB._addedBlocks = setCriteria(
        pValue,
        fotovisitaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fotovisitaFB._addedBlocks);
    _waitingNot = '';
    fotovisitaFB._addedBlocks.needEndBlock![fotovisitaFB._blockIndex] =
        fotovisitaFB._addedBlocks.retVal;
    return fotovisitaFB;
  }
}
// endregion FotoVisitaField

// region FotoVisitaFilterBuilder
class FotoVisitaFilterBuilder extends SearchCriteria {
  FotoVisitaFilterBuilder(FotoVisita obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  FotoVisita? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  FotoVisitaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  FotoVisitaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  FotoVisitaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  FotoVisitaFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  FotoVisitaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  FotoVisitaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  FotoVisitaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FotoVisitaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FotoVisitaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FotoVisitaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FotoVisitaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  FotoVisitaField setField(
      FotoVisitaField? field, String colName, DbType dbtype) {
    return FotoVisitaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  FotoVisitaField? _id;
  FotoVisitaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  FotoVisitaField? _imagen;
  FotoVisitaField get imagen {
    return _imagen = setField(_imagen, 'imagen', DbType.blob);
  }

  FotoVisitaField? _visitaId;
  FotoVisitaField get visitaId {
    return _visitaId = setField(_visitaId, 'visitaId', DbType.integer);
  }

  FotoVisitaField? _intervencionId;
  FotoVisitaField get intervencionId {
    return _intervencionId =
        setField(_intervencionId, 'intervencionId', DbType.integer);
  }

  FotoVisitaField? _nroComponente;
  FotoVisitaField get nroComponente {
    return _nroComponente =
        setField(_nroComponente, 'nroComponente', DbType.integer);
  }

  FotoVisitaField? _dateCreated;
  FotoVisitaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  FotoVisitaField? _isDeleted;
  FotoVisitaField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (FotoVisita._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<FotoVisita> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (FotoVisita._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnFotoVisita.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnFotoVisita.delete(qparams);
    }
    return r;
  }

  /// Recover List<FotoVisita> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover FotoVisita bulk invoked');
    return _obj!._mnFotoVisita.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from fotoVisita ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnFotoVisita.updateBatch(qparams, values);
  }

  /// This method always returns [FotoVisita] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> FotoVisita?
  Future<FotoVisita?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnFotoVisita.toList(qparams);
    final data = await objFuture;
    FotoVisita? obj;
    if (data.isNotEmpty) {
      obj = FotoVisita.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('visita.plVisita') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVisita'))) {
          /*_loadedfields!.add('visita.plVisita');*/ obj.plVisita = obj
                  .plVisita ??
              await obj.getVisita(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [FotoVisita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> FotoVisita?
  Future<FotoVisita> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        FotoVisita();
  }

  /// This method returns int. [FotoVisita]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? fotovisitaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final fotovisitasFuture = await _obj!._mnFotoVisita.toList(qparams);
    final int count = fotovisitasFuture[0]['CNT'] as int;
    if (fotovisitaCount != null) {
      fotovisitaCount(count);
    }
    return count;
  }

  /// This method returns List<FotoVisita> [FotoVisita]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FotoVisita>
  Future<List<FotoVisita>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FotoVisita> fotovisitasData = await FotoVisita.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return fotovisitasData;
  }

  /// This method returns Json String [FotoVisita]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FotoVisita]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FotoVisita]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnFotoVisita.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<FotoVisita>>
  Future<List<DropdownMenuItem<FotoVisita>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<FotoVisita>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final fotovisitasFuture = _obj!._mnFotoVisita.toList(qparams);

    final data = await fotovisitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<FotoVisita>> items = []..add(DropdownMenuItem(
        value: FotoVisita(),
        child: Text('Select FotoVisita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: FotoVisita.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final fotovisitasFuture = _obj!._mnFotoVisita.toList(qparams);

    final data = await fotovisitasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select FotoVisita'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FotoVisita]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM fotoVisita WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnFotoVisita.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FotoVisita]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnFotoVisita.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await FotoVisita.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnFotoVisita.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FotoVisitaFilterBuilder

// region FotoVisitaFields
class FotoVisitaFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fImagen;
  static TableField get imagen {
    return _fImagen =
        _fImagen ?? SqlSyntax.setField(_fImagen, 'imagen', DbType.blob);
  }

  static TableField? _fVisitaId;
  static TableField get visitaId {
    return _fVisitaId = _fVisitaId ??
        SqlSyntax.setField(_fVisitaId, 'visitaId', DbType.integer);
  }

  static TableField? _fIntervencionId;
  static TableField get intervencionId {
    return _fIntervencionId = _fIntervencionId ??
        SqlSyntax.setField(_fIntervencionId, 'intervencionId', DbType.integer);
  }

  static TableField? _fNroComponente;
  static TableField get nroComponente {
    return _fNroComponente = _fNroComponente ??
        SqlSyntax.setField(_fNroComponente, 'nroComponente', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion FotoVisitaFields

//region FotoVisitaManager
class FotoVisitaManager extends SqfEntityProvider {
  FotoVisitaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'fotoVisita';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion FotoVisitaManager
// region FotoVivienda
class FotoVivienda extends TableBase {
  FotoVivienda(
      {this.id,
      this.imagen,
      this.fotoPrincipal,
      this.viviendaId,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  FotoVivienda.withFields(this.imagen, this.fotoPrincipal, this.viviendaId,
      this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  FotoVivienda.withId(this.id, this.imagen, this.fotoPrincipal, this.viviendaId,
      this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FotoVivienda.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['imagen'] != null) {
      imagen = o['imagen'] as Uint8List;
    }
    if (o['fotoPrincipal'] != null) {
      fotoPrincipal = o['fotoPrincipal'].toString() == '1' ||
          o['fotoPrincipal'].toString() == 'true';
    }
    viviendaId = int.tryParse(o['viviendaId'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plVivienda = o['vivienda'] != null
        ? Vivienda.fromMap(o['vivienda'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (FotoVivienda)
  int? id;
  Uint8List? imagen;
  bool? fotoPrincipal;
  int? viviendaId;
  DateTime? dateCreated;
  bool? isDeleted;

  BoolResult? saveResult;
  // end FIELDS (FotoVivienda)

// RELATIONSHIPS (FotoVivienda)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVivienda', 'plField2'..]) or so on..
  Vivienda? plVivienda;

  /// get Vivienda By ViviendaId
  Future<Vivienda?> getVivienda(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Vivienda().getById(viviendaId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (FotoVivienda)

  static const bool _softDeleteActivated = true;
  FotoViviendaManager? __mnFotoVivienda;

  FotoViviendaManager get _mnFotoVivienda {
    return __mnFotoVivienda = __mnFotoVivienda ?? FotoViviendaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['imagen'] = imagen;
    if (fotoPrincipal != null) {
      map['fotoPrincipal'] =
          forQuery ? (fotoPrincipal! ? 1 : 0) : fotoPrincipal;
    } else {
      map['fotoPrincipal'] = null;
    }
    if (viviendaId != null) {
      map['viviendaId'] = forView
          ? plVivienda == null
              ? viviendaId
              : plVivienda!.aliasRenabap
          : viviendaId;
    } else {
      map['viviendaId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['imagen'] = imagen;
    if (fotoPrincipal != null) {
      map['fotoPrincipal'] =
          forQuery ? (fotoPrincipal! ? 1 : 0) : fotoPrincipal;
    } else {
      map['fotoPrincipal'] = null;
    }
    if (viviendaId != null) {
      map['viviendaId'] = forView
          ? plVivienda == null
              ? viviendaId
              : plVivienda!.aliasRenabap
          : viviendaId;
    } else {
      map['viviendaId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [FotoVivienda]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FotoVivienda]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      imagen,
      fotoPrincipal,
      viviendaId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      imagen,
      fotoPrincipal,
      viviendaId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<FotoVivienda>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FotoVivienda.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FotoVivienda>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FotoVivienda>[];
    try {
      objList = list
          .map((fotovivienda) =>
              FotoVivienda.fromMap(fotovivienda as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FotoVivienda.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FotoVivienda>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FotoVivienda> objList = <FotoVivienda>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FotoVivienda.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('vivienda.plVivienda') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVivienda'))) {
          /*_loadedfields!.add('vivienda.plVivienda');*/ obj.plVivienda = obj
                  .plVivienda ??
              await obj.getVivienda(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns FotoVivienda by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [FotoVivienda] if exist, otherwise returns null
  Future<FotoVivienda?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    FotoVivienda? obj;
    final data = await _mnFotoVivienda.getById([id]);
    if (data.length != 0) {
      obj = FotoVivienda.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('vivienda.plVivienda') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVivienda'))) {
          /*_loadedfields!.add('vivienda.plVivienda');*/ obj.plVivienda = obj
                  .plVivienda ??
              await obj.getVivienda(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FotoVivienda) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnFotoVivienda.insert(this, ignoreBatch);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFotoVivienda.update(this);
    }

    return id;
  }

  /// Saves the (FotoVivienda) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns id
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnFotoVivienda.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFotoVivienda.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs FotoVivienda. Returns a new Primary Key value of FotoVivienda

  /// <returns>Returns a new Primary Key value of FotoVivienda
  Future<int?> saveAs() async {
    id = null;

    return save();
  }

  void rollbackId() {
    if (isInsert == true) {
      id = null;
    }
  }

  /// saveAll method saves the sent List<FotoVivienda> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<FotoVivienda> fotoviviendas) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in fotoviviendas) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
      for (int i = 0; i < fotoviviendas.length; i++) {
        if (fotoviviendas[i].id == null) {
          fotoviviendas[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFotoVivienda.rawInsert(
          'INSERT OR REPLACE INTO fotoVivienda (id, imagen, fotoPrincipal, viviendaId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?)',
          [
            id,
            imagen,
            fotoPrincipal,
            viviendaId,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'FotoVivienda id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'FotoVivienda id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FotoVivienda Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<FotoVivienda>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<FotoVivienda> fotoviviendas) async {
    final results = await _mnFotoVivienda.rawInsertAll(
        'INSERT OR REPLACE INTO fotoVivienda (id, imagen, fotoPrincipal, viviendaId, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?)',
        fotoviviendas);
    return results;
  }

  /// Deletes FotoVivienda

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete FotoVivienda invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnFotoVivienda
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnFotoVivienda.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover FotoVivienda>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover FotoVivienda invoked (id=$id)');
    {
      return _mnFotoVivienda.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  FotoViviendaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FotoViviendaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  FotoViviendaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FotoViviendaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion fotovivienda

// region FotoViviendaField
class FotoViviendaField extends SearchCriteria {
  FotoViviendaField(this.fotoviviendaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  FotoViviendaFilterBuilder fotoviviendaFB;

  FotoViviendaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  FotoViviendaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    fotoviviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.EQuals, fotoviviendaFB._addedBlocks)
        : setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.NotEQuals, fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    fotoviviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.EQualsOrNull, fotoviviendaFB._addedBlocks)
        : setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder isNull() {
    fotoviviendaFB._addedBlocks = setCriteria(
        0,
        fotoviviendaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      fotoviviendaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          fotoviviendaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotoviviendaFB._addedBlocks);
      _waitingNot = '';
      fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
          fotoviviendaFB._addedBlocks.retVal;
    }
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      fotoviviendaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          fotoviviendaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotoviviendaFB._addedBlocks);
      _waitingNot = '';
      fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
          fotoviviendaFB._addedBlocks.retVal;
      fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
          fotoviviendaFB._addedBlocks.retVal;
    }
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      fotoviviendaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          fotoviviendaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotoviviendaFB._addedBlocks);
      _waitingNot = '';
      fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
          fotoviviendaFB._addedBlocks.retVal;
    }
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      fotoviviendaFB._addedBlocks = setCriteria(
          pFirst,
          fotoviviendaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          fotoviviendaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        fotoviviendaFB._addedBlocks = setCriteria(
            pFirst,
            fotoviviendaFB.parameters,
            param,
            SqlSyntax.LessThan,
            fotoviviendaFB._addedBlocks);
      } else {
        fotoviviendaFB._addedBlocks = setCriteria(
            pFirst,
            fotoviviendaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            fotoviviendaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        fotoviviendaFB._addedBlocks = setCriteria(
            pLast,
            fotoviviendaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            fotoviviendaFB._addedBlocks);
      } else {
        fotoviviendaFB._addedBlocks = setCriteria(
            pLast,
            fotoviviendaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            fotoviviendaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    fotoviviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.GreaterThan, fotoviviendaFB._addedBlocks)
        : setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    fotoviviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.LessThan, fotoviviendaFB._addedBlocks)
        : setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    fotoviviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, fotoviviendaFB._addedBlocks)
        : setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.LessThan, fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    fotoviviendaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, fotoviviendaFB._addedBlocks)
        : setCriteria(pValue, fotoviviendaFB.parameters, param,
            SqlSyntax.GreaterThan, fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }

  FotoViviendaFilterBuilder inValues(dynamic pValue) {
    fotoviviendaFB._addedBlocks = setCriteria(
        pValue,
        fotoviviendaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        fotoviviendaFB._addedBlocks);
    _waitingNot = '';
    fotoviviendaFB._addedBlocks.needEndBlock![fotoviviendaFB._blockIndex] =
        fotoviviendaFB._addedBlocks.retVal;
    return fotoviviendaFB;
  }
}
// endregion FotoViviendaField

// region FotoViviendaFilterBuilder
class FotoViviendaFilterBuilder extends SearchCriteria {
  FotoViviendaFilterBuilder(FotoVivienda obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  FotoVivienda? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  FotoViviendaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  FotoViviendaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  FotoViviendaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  FotoViviendaFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  FotoViviendaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  FotoViviendaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  FotoViviendaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FotoViviendaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FotoViviendaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  FotoViviendaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  FotoViviendaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  FotoViviendaField setField(
      FotoViviendaField? field, String colName, DbType dbtype) {
    return FotoViviendaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  FotoViviendaField? _id;
  FotoViviendaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  FotoViviendaField? _imagen;
  FotoViviendaField get imagen {
    return _imagen = setField(_imagen, 'imagen', DbType.blob);
  }

  FotoViviendaField? _fotoPrincipal;
  FotoViviendaField get fotoPrincipal {
    return _fotoPrincipal =
        setField(_fotoPrincipal, 'fotoPrincipal', DbType.bool);
  }

  FotoViviendaField? _viviendaId;
  FotoViviendaField get viviendaId {
    return _viviendaId = setField(_viviendaId, 'viviendaId', DbType.integer);
  }

  FotoViviendaField? _dateCreated;
  FotoViviendaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  FotoViviendaField? _isDeleted;
  FotoViviendaField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (FotoVivienda._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<FotoVivienda> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (FotoVivienda._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnFotoVivienda.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnFotoVivienda.delete(qparams);
    }
    return r;
  }

  /// Recover List<FotoVivienda> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover FotoVivienda bulk invoked');
    return _obj!._mnFotoVivienda.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from fotoVivienda ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnFotoVivienda.updateBatch(qparams, values);
  }

  /// This method always returns [FotoVivienda] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> FotoVivienda?
  Future<FotoVivienda?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnFotoVivienda.toList(qparams);
    final data = await objFuture;
    FotoVivienda? obj;
    if (data.isNotEmpty) {
      obj = FotoVivienda.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('vivienda.plVivienda') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plVivienda'))) {
          /*_loadedfields!.add('vivienda.plVivienda');*/ obj.plVivienda = obj
                  .plVivienda ??
              await obj.getVivienda(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [FotoVivienda]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> FotoVivienda?
  Future<FotoVivienda> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        FotoVivienda();
  }

  /// This method returns int. [FotoVivienda]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c)? fotoviviendaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final fotoviviendasFuture = await _obj!._mnFotoVivienda.toList(qparams);
    final int count = fotoviviendasFuture[0]['CNT'] as int;
    if (fotoviviendaCount != null) {
      fotoviviendaCount(count);
    }
    return count;
  }

  /// This method returns List<FotoVivienda> [FotoVivienda]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<FotoVivienda>
  Future<List<FotoVivienda>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FotoVivienda> fotoviviendasData = await FotoVivienda.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return fotoviviendasData;
  }

  /// This method returns Json String [FotoVivienda]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FotoVivienda]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FotoVivienda]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnFotoVivienda.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<FotoVivienda>>
  Future<List<DropdownMenuItem<FotoVivienda>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<FotoVivienda>> o)?
          dropDownMenu]) async {
    _buildParameters();
    final fotoviviendasFuture = _obj!._mnFotoVivienda.toList(qparams);

    final data = await fotoviviendasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<FotoVivienda>> items = []..add(DropdownMenuItem(
        value: FotoVivienda(),
        child: Text('Select FotoVivienda'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: FotoVivienda.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final fotoviviendasFuture = _obj!._mnFotoVivienda.toList(qparams);

    final data = await fotoviviendasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select FotoVivienda'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FotoVivienda]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM fotoVivienda WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj!._mnFotoVivienda.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FotoVivienda]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnFotoVivienda.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await FotoVivienda.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnFotoVivienda.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FotoViviendaFilterBuilder

// region FotoViviendaFields
class FotoViviendaFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fImagen;
  static TableField get imagen {
    return _fImagen =
        _fImagen ?? SqlSyntax.setField(_fImagen, 'imagen', DbType.blob);
  }

  static TableField? _fFotoPrincipal;
  static TableField get fotoPrincipal {
    return _fFotoPrincipal = _fFotoPrincipal ??
        SqlSyntax.setField(_fFotoPrincipal, 'fotoPrincipal', DbType.bool);
  }

  static TableField? _fViviendaId;
  static TableField get viviendaId {
    return _fViviendaId = _fViviendaId ??
        SqlSyntax.setField(_fViviendaId, 'viviendaId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion FotoViviendaFields

//region FotoViviendaManager
class FotoViviendaManager extends SqfEntityProvider {
  FotoViviendaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'fotoVivienda';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion FotoViviendaManager
// region DocumentacionTecnica
class DocumentacionTecnica extends TableBase {
  DocumentacionTecnica(
      {this.datos,
      this.computo,
      this.planosDeObra,
      this.cuadrillaDeTrabajadores,
      this.sintesisDiagnosticoDeViviendas,
      this.certificadoAvanceObra,
      this.planDeObra,
      this.diagramaGantt,
      this.obraId,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  DocumentacionTecnica.withFields(
      this.datos,
      this.computo,
      this.planosDeObra,
      this.cuadrillaDeTrabajadores,
      this.sintesisDiagnosticoDeViviendas,
      this.certificadoAvanceObra,
      this.planDeObra,
      this.diagramaGantt,
      this.obraId,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  DocumentacionTecnica.withId(
      this.datos,
      this.computo,
      this.planosDeObra,
      this.cuadrillaDeTrabajadores,
      this.sintesisDiagnosticoDeViviendas,
      this.certificadoAvanceObra,
      this.planDeObra,
      this.diagramaGantt,
      this.obraId,
      this._id,
      this.dateCreated,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DocumentacionTecnica.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['datos'] != null) {
      datos = o['datos'] as Uint8List;
    }
    if (o['computo'] != null) {
      computo = o['computo'] as Uint8List;
    }
    if (o['planosDeObra'] != null) {
      planosDeObra = o['planosDeObra'] as Uint8List;
    }
    if (o['cuadrillaDeTrabajadores'] != null) {
      cuadrillaDeTrabajadores = o['cuadrillaDeTrabajadores'] as Uint8List;
    }
    if (o['sintesisDiagnosticoDeViviendas'] != null) {
      sintesisDiagnosticoDeViviendas =
          o['sintesisDiagnosticoDeViviendas'] as Uint8List;
    }
    if (o['certificadoAvanceObra'] != null) {
      certificadoAvanceObra = o['certificadoAvanceObra'] as Uint8List;
    }
    if (o['planDeObra'] != null) {
      planDeObra = o['planDeObra'] as Uint8List;
    }
    if (o['diagramaGantt'] != null) {
      diagramaGantt = o['diagramaGantt'] as Uint8List;
    }
    obraId = int.tryParse(o['obraId'].toString());

    _id = int.tryParse(o['_id'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plObra = o['obra'] != null
        ? Obra.fromMap(o['obra'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (DocumentacionTecnica)
  Uint8List? datos;
  Uint8List? computo;
  Uint8List? planosDeObra;
  Uint8List? cuadrillaDeTrabajadores;
  Uint8List? sintesisDiagnosticoDeViviendas;
  Uint8List? certificadoAvanceObra;
  Uint8List? planDeObra;
  Uint8List? diagramaGantt;
  int? obraId;
  int? _id;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (DocumentacionTecnica)

// RELATIONSHIPS (DocumentacionTecnica)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plObra', 'plField2'..]) or so on..
  Obra? plObra;

  /// get Obra By ObraId
  Future<Obra?> getObra(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Obra()
        .getById(obraId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DocumentacionTecnica)

  static const bool _softDeleteActivated = true;
  DocumentacionTecnicaManager? __mnDocumentacionTecnica;

  DocumentacionTecnicaManager get _mnDocumentacionTecnica {
    return __mnDocumentacionTecnica =
        __mnDocumentacionTecnica ?? DocumentacionTecnicaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['datos'] = datos;
    map['computo'] = computo;
    map['planosDeObra'] = planosDeObra;
    map['cuadrillaDeTrabajadores'] = cuadrillaDeTrabajadores;
    map['sintesisDiagnosticoDeViviendas'] = sintesisDiagnosticoDeViviendas;
    map['certificadoAvanceObra'] = certificadoAvanceObra;
    map['planDeObra'] = planDeObra;
    map['diagramaGantt'] = diagramaGantt;
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    map['_id'] = _id;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['datos'] = datos;
    map['computo'] = computo;
    map['planosDeObra'] = planosDeObra;
    map['cuadrillaDeTrabajadores'] = cuadrillaDeTrabajadores;
    map['sintesisDiagnosticoDeViviendas'] = sintesisDiagnosticoDeViviendas;
    map['certificadoAvanceObra'] = certificadoAvanceObra;
    map['planDeObra'] = planDeObra;
    map['diagramaGantt'] = diagramaGantt;
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    map['_id'] = _id;
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [DocumentacionTecnica]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DocumentacionTecnica]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      datos,
      computo,
      planosDeObra,
      cuadrillaDeTrabajadores,
      sintesisDiagnosticoDeViviendas,
      certificadoAvanceObra,
      planDeObra,
      diagramaGantt,
      obraId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      datos,
      computo,
      planosDeObra,
      cuadrillaDeTrabajadores,
      sintesisDiagnosticoDeViviendas,
      certificadoAvanceObra,
      planDeObra,
      diagramaGantt,
      obraId,
      _id,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<DocumentacionTecnica>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DocumentacionTecnica.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DocumentacionTecnica>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DocumentacionTecnica>[];
    try {
      objList = list
          .map((documentaciontecnica) => DocumentacionTecnica.fromMap(
              documentaciontecnica as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DocumentacionTecnica.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DocumentacionTecnica>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DocumentacionTecnica> objList = <DocumentacionTecnica>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DocumentacionTecnica.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DocumentacionTecnica by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? _id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [DocumentacionTecnica] if exist, otherwise returns null
  Future<DocumentacionTecnica?> getById(int? _id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (_id == null) {
      return null;
    }
    DocumentacionTecnica? obj;
    final data = await _mnDocumentacionTecnica.getById([_id]);
    if (data.length != 0) {
      obj = DocumentacionTecnica.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DocumentacionTecnica) object. If the _id field is null, saves as a new record and returns new _id, if _id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns _id
  Future<int?> _save({bool ignoreBatch = true}) async {
    if (_id == null || _id == 0 || !isSaved!) {
      await _mnDocumentacionTecnica.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      // _id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDocumentacionTecnica.update(this);
    }

    return _id;
  }

  /// Saves the (DocumentacionTecnica) object. If the _id field is null, saves as a new record and returns new _id, if _id is not null then updates record
  ///
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  ///
  /// <returns>Returns _id
  Future<int?> _saveOrThrow({bool ignoreBatch = true}) async {
    if (_id == null || _id == 0 || !isSaved!) {
      await _mnDocumentacionTecnica.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // _id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDocumentacionTecnica.updateOrThrow(this);
    }

    return _id;
  }

  void rollbackId() {
    if (isInsert == true) {
      _id = null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns _id

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDocumentacionTecnica.rawInsert(
          'INSERT OR REPLACE INTO documentacionTecnica ( datos, computo, planosDeObra, cuadrillaDeTrabajadores, sintesisDiagnosticoDeViviendas, certificadoAvanceObra, planDeObra, diagramaGantt, obraId, _id, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            datos,
            computo,
            planosDeObra,
            cuadrillaDeTrabajadores,
            sintesisDiagnosticoDeViviendas,
            certificadoAvanceObra,
            planDeObra,
            diagramaGantt,
            obraId,
            _id,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DocumentacionTecnica _id=$_id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DocumentacionTecnica _id=$_id did not update');
      }
      return _id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DocumentacionTecnica Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes DocumentacionTecnica

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete DocumentacionTecnica invoked (_id=$_id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnDocumentacionTecnica
          .delete(QueryParams(whereString: '_id=?', whereArguments: [_id]));
    } else {
      return _mnDocumentacionTecnica.updateBatch(
          QueryParams(whereString: '_id=?', whereArguments: [_id]),
          {'isDeleted': 1});
    }
  }

  /// Recover DocumentacionTecnica>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover DocumentacionTecnica invoked (_id=$_id)');
    {
      return _mnDocumentacionTecnica.updateBatch(
          QueryParams(whereString: '_id=?', whereArguments: [_id]),
          {'isDeleted': 0});
    }
  }

  DocumentacionTecnicaFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DocumentacionTecnicaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DocumentacionTecnicaFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DocumentacionTecnicaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion documentaciontecnica

// region DocumentacionTecnicaField
class DocumentacionTecnicaField extends SearchCriteria {
  DocumentacionTecnicaField(this.documentaciontecnicaFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  DocumentacionTecnicaFilterBuilder documentaciontecnicaFB;

  DocumentacionTecnicaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DocumentacionTecnicaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    documentaciontecnicaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.EQuals, documentaciontecnicaFB._addedBlocks)
        : setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.NotEQuals, documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    documentaciontecnicaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.EQualsOrNull, documentaciontecnicaFB._addedBlocks)
        : setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder isNull() {
    documentaciontecnicaFB._addedBlocks = setCriteria(
        0,
        documentaciontecnicaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      documentaciontecnicaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          documentaciontecnicaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          documentaciontecnicaFB._addedBlocks);
      _waitingNot = '';
      documentaciontecnicaFB
              ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
          documentaciontecnicaFB._addedBlocks.retVal;
    }
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      documentaciontecnicaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          documentaciontecnicaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          documentaciontecnicaFB._addedBlocks);
      _waitingNot = '';
      documentaciontecnicaFB
              ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
          documentaciontecnicaFB._addedBlocks.retVal;
      documentaciontecnicaFB
              ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
          documentaciontecnicaFB._addedBlocks.retVal;
    }
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      documentaciontecnicaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          documentaciontecnicaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          documentaciontecnicaFB._addedBlocks);
      _waitingNot = '';
      documentaciontecnicaFB
              ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
          documentaciontecnicaFB._addedBlocks.retVal;
    }
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      documentaciontecnicaFB._addedBlocks = setCriteria(
          pFirst,
          documentaciontecnicaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          documentaciontecnicaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        documentaciontecnicaFB._addedBlocks = setCriteria(
            pFirst,
            documentaciontecnicaFB.parameters,
            param,
            SqlSyntax.LessThan,
            documentaciontecnicaFB._addedBlocks);
      } else {
        documentaciontecnicaFB._addedBlocks = setCriteria(
            pFirst,
            documentaciontecnicaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            documentaciontecnicaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        documentaciontecnicaFB._addedBlocks = setCriteria(
            pLast,
            documentaciontecnicaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            documentaciontecnicaFB._addedBlocks);
      } else {
        documentaciontecnicaFB._addedBlocks = setCriteria(
            pLast,
            documentaciontecnicaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            documentaciontecnicaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    documentaciontecnicaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.GreaterThan, documentaciontecnicaFB._addedBlocks)
        : setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    documentaciontecnicaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.LessThan, documentaciontecnicaFB._addedBlocks)
        : setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    documentaciontecnicaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, documentaciontecnicaFB._addedBlocks)
        : setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.LessThan, documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    documentaciontecnicaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, documentaciontecnicaFB._addedBlocks)
        : setCriteria(pValue, documentaciontecnicaFB.parameters, param,
            SqlSyntax.GreaterThan, documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }

  DocumentacionTecnicaFilterBuilder inValues(dynamic pValue) {
    documentaciontecnicaFB._addedBlocks = setCriteria(
        pValue,
        documentaciontecnicaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        documentaciontecnicaFB._addedBlocks);
    _waitingNot = '';
    documentaciontecnicaFB
            ._addedBlocks.needEndBlock![documentaciontecnicaFB._blockIndex] =
        documentaciontecnicaFB._addedBlocks.retVal;
    return documentaciontecnicaFB;
  }
}
// endregion DocumentacionTecnicaField

// region DocumentacionTecnicaFilterBuilder
class DocumentacionTecnicaFilterBuilder extends SearchCriteria {
  DocumentacionTecnicaFilterBuilder(DocumentacionTecnica obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  DocumentacionTecnica? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  DocumentacionTecnicaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DocumentacionTecnicaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DocumentacionTecnicaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DocumentacionTecnicaFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DocumentacionTecnicaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DocumentacionTecnicaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DocumentacionTecnicaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DocumentacionTecnicaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DocumentacionTecnicaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DocumentacionTecnicaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DocumentacionTecnicaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DocumentacionTecnicaField setField(
      DocumentacionTecnicaField? field, String colName, DbType dbtype) {
    return DocumentacionTecnicaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  DocumentacionTecnicaField? _datos;
  DocumentacionTecnicaField get datos {
    return _datos = setField(_datos, 'datos', DbType.blob);
  }

  DocumentacionTecnicaField? _computo;
  DocumentacionTecnicaField get computo {
    return _computo = setField(_computo, 'computo', DbType.blob);
  }

  DocumentacionTecnicaField? _planosDeObra;
  DocumentacionTecnicaField get planosDeObra {
    return _planosDeObra = setField(_planosDeObra, 'planosDeObra', DbType.blob);
  }

  DocumentacionTecnicaField? _cuadrillaDeTrabajadores;
  DocumentacionTecnicaField get cuadrillaDeTrabajadores {
    return _cuadrillaDeTrabajadores = setField(
        _cuadrillaDeTrabajadores, 'cuadrillaDeTrabajadores', DbType.blob);
  }

  DocumentacionTecnicaField? _sintesisDiagnosticoDeViviendas;
  DocumentacionTecnicaField get sintesisDiagnosticoDeViviendas {
    return _sintesisDiagnosticoDeViviendas = setField(
        _sintesisDiagnosticoDeViviendas,
        'sintesisDiagnosticoDeViviendas',
        DbType.blob);
  }

  DocumentacionTecnicaField? _certificadoAvanceObra;
  DocumentacionTecnicaField get certificadoAvanceObra {
    return _certificadoAvanceObra =
        setField(_certificadoAvanceObra, 'certificadoAvanceObra', DbType.blob);
  }

  DocumentacionTecnicaField? _planDeObra;
  DocumentacionTecnicaField get planDeObra {
    return _planDeObra = setField(_planDeObra, 'planDeObra', DbType.blob);
  }

  DocumentacionTecnicaField? _diagramaGantt;
  DocumentacionTecnicaField get diagramaGantt {
    return _diagramaGantt =
        setField(_diagramaGantt, 'diagramaGantt', DbType.blob);
  }

  DocumentacionTecnicaField? _obraId;
  DocumentacionTecnicaField get obraId {
    return _obraId = setField(_obraId, 'obraId', DbType.integer);
  }

  DocumentacionTecnicaField? __id;
  DocumentacionTecnicaField get _id {
    return __id = setField(__id, '_id', DbType.integer);
  }

  DocumentacionTecnicaField? _dateCreated;
  DocumentacionTecnicaField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  DocumentacionTecnicaField? _isDeleted;
  DocumentacionTecnicaField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DocumentacionTecnica._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DocumentacionTecnica> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (DocumentacionTecnica._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnDocumentacionTecnica
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnDocumentacionTecnica.delete(qparams);
    }
    return r;
  }

  /// Recover List<DocumentacionTecnica> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover DocumentacionTecnica bulk invoked');
    return _obj!._mnDocumentacionTecnica.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          '_id IN (SELECT _id from documentacionTecnica ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnDocumentacionTecnica.updateBatch(qparams, values);
  }

  /// This method always returns [DocumentacionTecnica] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> DocumentacionTecnica?
  Future<DocumentacionTecnica?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnDocumentacionTecnica.toList(qparams);
    final data = await objFuture;
    DocumentacionTecnica? obj;
    if (data.isNotEmpty) {
      obj = DocumentacionTecnica.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DocumentacionTecnica]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> DocumentacionTecnica?
  Future<DocumentacionTecnica> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DocumentacionTecnica();
  }

  /// This method returns int. [DocumentacionTecnica]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? documentaciontecnicaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final documentaciontecnicasFuture =
        await _obj!._mnDocumentacionTecnica.toList(qparams);
    final int count = documentaciontecnicasFuture[0]['CNT'] as int;
    if (documentaciontecnicaCount != null) {
      documentaciontecnicaCount(count);
    }
    return count;
  }

  /// This method returns List<DocumentacionTecnica> [DocumentacionTecnica]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DocumentacionTecnica>
  Future<List<DocumentacionTecnica>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DocumentacionTecnica> documentaciontecnicasData =
        await DocumentacionTecnica.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return documentaciontecnicasData;
  }

  /// This method returns Json String [DocumentacionTecnica]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DocumentacionTecnica]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DocumentacionTecnica]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnDocumentacionTecnica.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DocumentacionTecnica]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `_id` FROM documentacionTecnica WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> _idData = <int>[];
    qparams.selectColumns = ['_id'];
    final _idFuture = await _obj!._mnDocumentacionTecnica.toList(qparams);

    final int count = _idFuture.length;
    for (int i = 0; i < count; i++) {
      _idData.add(_idFuture[i]['_id'] as int);
    }
    return _idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DocumentacionTecnica]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnDocumentacionTecnica.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DocumentacionTecnica.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnDocumentacionTecnica.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DocumentacionTecnicaFilterBuilder

// region DocumentacionTecnicaFields
class DocumentacionTecnicaFields {
  static TableField? _fDatos;
  static TableField get datos {
    return _fDatos =
        _fDatos ?? SqlSyntax.setField(_fDatos, 'datos', DbType.blob);
  }

  static TableField? _fComputo;
  static TableField get computo {
    return _fComputo =
        _fComputo ?? SqlSyntax.setField(_fComputo, 'computo', DbType.blob);
  }

  static TableField? _fPlanosDeObra;
  static TableField get planosDeObra {
    return _fPlanosDeObra = _fPlanosDeObra ??
        SqlSyntax.setField(_fPlanosDeObra, 'planosDeObra', DbType.blob);
  }

  static TableField? _fCuadrillaDeTrabajadores;
  static TableField get cuadrillaDeTrabajadores {
    return _fCuadrillaDeTrabajadores = _fCuadrillaDeTrabajadores ??
        SqlSyntax.setField(
            _fCuadrillaDeTrabajadores, 'cuadrillaDeTrabajadores', DbType.blob);
  }

  static TableField? _fSintesisDiagnosticoDeViviendas;
  static TableField get sintesisDiagnosticoDeViviendas {
    return _fSintesisDiagnosticoDeViviendas =
        _fSintesisDiagnosticoDeViviendas ??
            SqlSyntax.setField(_fSintesisDiagnosticoDeViviendas,
                'sintesisDiagnosticoDeViviendas', DbType.blob);
  }

  static TableField? _fCertificadoAvanceObra;
  static TableField get certificadoAvanceObra {
    return _fCertificadoAvanceObra = _fCertificadoAvanceObra ??
        SqlSyntax.setField(
            _fCertificadoAvanceObra, 'certificadoAvanceObra', DbType.blob);
  }

  static TableField? _fPlanDeObra;
  static TableField get planDeObra {
    return _fPlanDeObra = _fPlanDeObra ??
        SqlSyntax.setField(_fPlanDeObra, 'planDeObra', DbType.blob);
  }

  static TableField? _fDiagramaGantt;
  static TableField get diagramaGantt {
    return _fDiagramaGantt = _fDiagramaGantt ??
        SqlSyntax.setField(_fDiagramaGantt, 'diagramaGantt', DbType.blob);
  }

  static TableField? _fObraId;
  static TableField get obraId {
    return _fObraId =
        _fObraId ?? SqlSyntax.setField(_fObraId, 'obraId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion DocumentacionTecnicaFields

//region DocumentacionTecnicaManager
class DocumentacionTecnicaManager extends SqfEntityProvider {
  DocumentacionTecnicaManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'documentacionTecnica';
  static const List<String> _primaryKeyList = ['_id'];
  static const String _whereStr = '_id=?';
}

//endregion DocumentacionTecnicaManager
// region Obra_intervencion
class Obra_intervencion extends TableBase {
  Obra_intervencion(
      {this.nroComponente,
      this.intervencionId,
      this.obraId,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
  }
  Obra_intervencion.withFields(this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Obra_intervencion.withId(this.nroComponente, this.intervencionId, this.obraId,
      this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Obra_intervencion.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['nroComponente'] != null) {
      nroComponente = int.tryParse(o['nroComponente'].toString());
    }
    intervencionId = int.tryParse(o['intervencionId'].toString());

    obraId = int.tryParse(o['obraId'].toString());

    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plIntervencion = o['intervencion'] != null
        ? Intervencion.fromMap(o['intervencion'] as Map<String, dynamic>)
        : null;
    plObra = o['obra'] != null
        ? Obra.fromMap(o['obra'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Obra_intervencion)
  int? nroComponente;
  int? intervencionId;
  int? obraId;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  BoolResult? saveResult;
  // end FIELDS (Obra_intervencion)

// RELATIONSHIPS (Obra_intervencion)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plIntervencion', 'plField2'..]) or so on..
  Intervencion? plIntervencion;

  /// get Intervencion By IntervencionId
  Future<Intervencion?> getIntervencion(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Intervencion().getById(intervencionId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plObra', 'plField2'..]) or so on..
  Obra? plObra;

  /// get Obra By ObraId
  Future<Obra?> getObra(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Obra()
        .getById(obraId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Obra_intervencion)

  static const bool _softDeleteActivated = true;
  Obra_intervencionManager? __mnObra_intervencion;

  Obra_intervencionManager get _mnObra_intervencion {
    return __mnObra_intervencion =
        __mnObra_intervencion ?? Obra_intervencionManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['nroComponente'] = nroComponente;
    if (intervencionId != null) {
      map['intervencionId'] = forView
          ? plIntervencion == null
              ? intervencionId
              : plIntervencion!.nombre
          : intervencionId;
    } else {
      map['intervencionId'] = null;
    }
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['nroComponente'] = nroComponente;
    if (intervencionId != null) {
      map['intervencionId'] = forView
          ? plIntervencion == null
              ? intervencionId
              : plIntervencion!.nombre
          : intervencionId;
    } else {
      map['intervencionId'] = null;
    }
    if (obraId != null) {
      map['obraId'] = forView
          ? plObra == null
              ? obraId
              : plObra!.nombreRepresentanteOSC
          : obraId;
    } else {
      map['obraId'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Obra_intervencion]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Obra_intervencion]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      nroComponente,
      intervencionId,
      obraId,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Obra_intervencion>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Obra_intervencion.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Obra_intervencion>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Obra_intervencion>[];
    try {
      objList = list
          .map((obra_intervencion) => Obra_intervencion.fromMap(
              obra_intervencion as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Obra_intervencion.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Obra_intervencion>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Obra_intervencion> objList = <Obra_intervencion>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Obra_intervencion.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Obra_intervencion by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int? nroComponente, int? intervencionId, int? obraId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns [Obra_intervencion] if exist, otherwise returns null
  Future<Obra_intervencion?> getById(
      int? nroComponente, int? intervencionId, int? obraId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (nroComponente == null) {
      return null;
    }
    Obra_intervencion? obj;
    final data = await _mnObra_intervencion
        .getById([nroComponente, intervencionId, obraId]);
    if (data.length != 0) {
      obj = Obra_intervencion.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Obra_intervencion) object. If the Primary Key (nroComponente) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same nroComponente
  ///
  /// <returns>Returns BoolResult
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnObra_intervencion.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO obra_intervencion ( nroComponente, intervencionId, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  void rollbackId() {
    if (isInsert == true) {
      nroComponente = null;
    }
  }

  /// saveAll method saves the sent List<Obra_intervencion> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Obra_intervencion> obra_intervencions) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in obra_intervencions) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit();
      for (int i = 0; i < obra_intervencions.length; i++) {
        if (obra_intervencions[i].nroComponente == null) {
          obra_intervencions[i].nroComponente = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns nroComponente

  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnObra_intervencion.rawInsert(
          'INSERT OR REPLACE INTO obra_intervencion ( nroComponente, intervencionId, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
          [
            nroComponente,
            intervencionId,
            obraId,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Obra_intervencion nroComponente=$nroComponente updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Obra_intervencion nroComponente=$nroComponente did not update');
      }
      return nroComponente;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Obra_intervencion Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Obra_intervencion>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<Obra_intervencion> obra_intervencions) async {
    final results = await _mnObra_intervencion.rawInsertAll(
        'INSERT OR REPLACE INTO obra_intervencion ( nroComponente, intervencionId, obraId, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
        obra_intervencions);
    return results;
  }

  /// Deletes Obra_intervencion

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted

  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Obra_intervencion invoked (nroComponente=$nroComponente)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnObra_intervencion.delete(QueryParams(
          whereString: 'nroComponente=? AND intervencionId=? AND obraId=?',
          whereArguments: [nroComponente, intervencionId, obraId]));
    } else {
      return _mnObra_intervencion.updateBatch(
          QueryParams(
              whereString: 'nroComponente=? AND intervencionId=? AND obraId=?',
              whereArguments: [nroComponente, intervencionId, obraId]),
          {'isDeleted': 1});
    }
  }

  /// Recover Obra_intervencion>

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint(
        'SQFENTITIY: recover Obra_intervencion invoked (nroComponente=$nroComponente)');
    {
      return _mnObra_intervencion.updateBatch(
          QueryParams(
              whereString: 'nroComponente=? AND intervencionId=? AND obraId=?',
              whereArguments: [nroComponente, intervencionId, obraId]),
          {'isDeleted': 0});
    }
  }

  Obra_intervencionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Obra_intervencionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  Obra_intervencionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Obra_intervencionFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }
  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion obra_intervencion

// region Obra_intervencionField
class Obra_intervencionField extends SearchCriteria {
  Obra_intervencionField(this.obra_intervencionFB);
  // { param = DbParameter(); }
  DbParameter param = DbParameter();
  String _waitingNot = '';
  Obra_intervencionFilterBuilder obra_intervencionFB;

  Obra_intervencionField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  Obra_intervencionFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    obra_intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.EQuals, obra_intervencionFB._addedBlocks)
        : setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.NotEQuals, obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    obra_intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.EQualsOrNull, obra_intervencionFB._addedBlocks)
        : setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder isNull() {
    obra_intervencionFB._addedBlocks = setCriteria(
        0,
        obra_intervencionFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      obra_intervencionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          obra_intervencionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obra_intervencionFB._addedBlocks);
      _waitingNot = '';
      obra_intervencionFB
              ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
          obra_intervencionFB._addedBlocks.retVal;
    }
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      obra_intervencionFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          obra_intervencionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obra_intervencionFB._addedBlocks);
      _waitingNot = '';
      obra_intervencionFB
              ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
          obra_intervencionFB._addedBlocks.retVal;
      obra_intervencionFB
              ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
          obra_intervencionFB._addedBlocks.retVal;
    }
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      obra_intervencionFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          obra_intervencionFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obra_intervencionFB._addedBlocks);
      _waitingNot = '';
      obra_intervencionFB
              ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
          obra_intervencionFB._addedBlocks.retVal;
    }
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      obra_intervencionFB._addedBlocks = setCriteria(
          pFirst,
          obra_intervencionFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          obra_intervencionFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        obra_intervencionFB._addedBlocks = setCriteria(
            pFirst,
            obra_intervencionFB.parameters,
            param,
            SqlSyntax.LessThan,
            obra_intervencionFB._addedBlocks);
      } else {
        obra_intervencionFB._addedBlocks = setCriteria(
            pFirst,
            obra_intervencionFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            obra_intervencionFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        obra_intervencionFB._addedBlocks = setCriteria(
            pLast,
            obra_intervencionFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            obra_intervencionFB._addedBlocks);
      } else {
        obra_intervencionFB._addedBlocks = setCriteria(
            pLast,
            obra_intervencionFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            obra_intervencionFB._addedBlocks);
      }
    }
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    obra_intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.GreaterThan, obra_intervencionFB._addedBlocks)
        : setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    obra_intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.LessThan, obra_intervencionFB._addedBlocks)
        : setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    obra_intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, obra_intervencionFB._addedBlocks)
        : setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.LessThan, obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    obra_intervencionFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, obra_intervencionFB._addedBlocks)
        : setCriteria(pValue, obra_intervencionFB.parameters, param,
            SqlSyntax.GreaterThan, obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }

  Obra_intervencionFilterBuilder inValues(dynamic pValue) {
    obra_intervencionFB._addedBlocks = setCriteria(
        pValue,
        obra_intervencionFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        obra_intervencionFB._addedBlocks);
    _waitingNot = '';
    obra_intervencionFB
            ._addedBlocks.needEndBlock![obra_intervencionFB._blockIndex] =
        obra_intervencionFB._addedBlocks.retVal;
    return obra_intervencionFB;
  }
}
// endregion Obra_intervencionField

// region Obra_intervencionFilterBuilder
class Obra_intervencionFilterBuilder extends SearchCriteria {
  Obra_intervencionFilterBuilder(Obra_intervencion obj) {
    whereString = '';
    groupByList = <String>[];
    _addedBlocks.needEndBlock!.add(false);
    _addedBlocks.waitingStartBlock!.add(false);
    _obj = obj;
  }
  AddedBlocks _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
  int _blockIndex = 0;
  List<DbParameter> parameters = <DbParameter>[];
  List<String> orderByList = <String>[];
  Obra_intervencion? _obj;
  QueryParams qparams = QueryParams();
  int _pagesize = 0;
  int _page = 0;

  /// put the sql keyword 'AND'
  Obra_intervencionFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  Obra_intervencionFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  Obra_intervencionFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock!.add(true);
    _addedBlocks.needEndBlock!.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock![_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  Obra_intervencionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock![_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  Obra_intervencionFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  Obra_intervencionFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  Obra_intervencionFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock![_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock!.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock!.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Obra_intervencionFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Obra_intervencionFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  Obra_intervencionFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  Obra_intervencionFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String? s in argFields as List<String?>) {
          if (s!.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  Obra_intervencionField setField(
      Obra_intervencionField? field, String colName, DbType dbtype) {
    return Obra_intervencionField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock![_blockIndex]);
  }

  Obra_intervencionField? _nroComponente;
  Obra_intervencionField get nroComponente {
    return _nroComponente =
        setField(_nroComponente, 'nroComponente', DbType.integer);
  }

  Obra_intervencionField? _intervencionId;
  Obra_intervencionField get intervencionId {
    return _intervencionId =
        setField(_intervencionId, 'intervencionId', DbType.integer);
  }

  Obra_intervencionField? _obraId;
  Obra_intervencionField get obraId {
    return _obraId = setField(_obraId, 'obraId', DbType.integer);
  }

  Obra_intervencionField? _dateCreated;
  Obra_intervencionField get dateCreated {
    return _dateCreated =
        setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  Obra_intervencionField? _isDeleted;
  Obra_intervencionField get isDeleted {
    return _isDeleted = setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  bool _getIsDeleted = false;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text || param.value[0] is String
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName!)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName!);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value = param.value == null
                  ? null
                  : param.value == true
                      ? 1
                      : 0;
              param.value2 = param.value2 == null
                  ? null
                  : param.value2 == true
                      ? 1
                      : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Obra_intervencion._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Obra_intervencion> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult(success: false);

    if (Obra_intervencion._softDeleteActivated && !hardDelete) {
      r = await _obj!._mnObra_intervencion
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj!._mnObra_intervencion.delete(qparams);
    }
    return r;
  }

  /// Recover List<Obra_intervencion> bulk by query
  Future<BoolResult> recover() async {
    _getIsDeleted = true;
    _buildParameters();
    debugPrint('SQFENTITIY: recover Obra_intervencion bulk invoked');
    return _obj!._mnObra_intervencion.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'nroComponente IN (SELECT nroComponente from obra_intervencion ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj!._mnObra_intervencion.updateBatch(qparams, values);
  }

  /// This method always returns [Obra_intervencion] Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Obra_intervencion?
  Future<Obra_intervencion?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj!._mnObra_intervencion.toList(qparams);
    final data = await objFuture;
    Obra_intervencion? obj;
    if (data.isNotEmpty) {
      obj = Obra_intervencion.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('intervencion.plIntervencion') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plIntervencion'))) {
          /*_loadedfields!.add('intervencion.plIntervencion');*/ obj
              .plIntervencion = obj
                  .plIntervencion ??
              await obj.getIntervencion(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedfields!.contains('obra.plObra') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plObra'))) {
          /*_loadedfields!.add('obra.plObra');*/ obj.plObra = obj.plObra ??
              await obj.getObra(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Obra_intervencion]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns> Obra_intervencion?
  Future<Obra_intervencion> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Obra_intervencion();
  }

  /// This method returns int. [Obra_intervencion]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c)? obra_intervencionCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final obra_intervencionsFuture =
        await _obj!._mnObra_intervencion.toList(qparams);
    final int count = obra_intervencionsFuture[0]['CNT'] as int;
    if (obra_intervencionCount != null) {
      obra_intervencionCount(count);
    }
    return count;
  }

  /// This method returns List<Obra_intervencion> [Obra_intervencion]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Obra_intervencion>
  Future<List<Obra_intervencion>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Obra_intervencion> obra_intervencionsData =
        await Obra_intervencion.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return obra_intervencionsData;
  }

  /// This method returns Json String [Obra_intervencion]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Obra_intervencion]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Obra_intervencion]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj!._mnObra_intervencion.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Obra_intervencion]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `nroComponente`intervencionId`obraId` FROM obra_intervencion WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<nroComponente,intervencionId,obraId> [Obra_intervencion]
  /// <returns>List<nroComponente,intervencionId,obraId>
  Future<List<Obra_intervencion>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['nroComponente', 'intervencionId', 'obraId'];
    final obra_intervencionFuture =
        await _obj!._mnObra_intervencion.toList(qparams);
    return await Obra_intervencion.fromMapList(obra_intervencionFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Obra_intervencion]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj!._mnObra_intervencion.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Obra_intervencion.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    _buildParameters();

    final objectFuture = _obj!._mnObra_intervencion.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Obra_intervencionFilterBuilder

// region Obra_intervencionFields
class Obra_intervencionFields {
  static TableField? _fNroComponente;
  static TableField get nroComponente {
    return _fNroComponente = _fNroComponente ??
        SqlSyntax.setField(_fNroComponente, 'nroComponente', DbType.integer);
  }

  static TableField? _fIntervencionId;
  static TableField get intervencionId {
    return _fIntervencionId = _fIntervencionId ??
        SqlSyntax.setField(_fIntervencionId, 'intervencionId', DbType.integer);
  }

  static TableField? _fObraId;
  static TableField get obraId {
    return _fObraId =
        _fObraId ?? SqlSyntax.setField(_fObraId, 'obraId', DbType.integer);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion Obra_intervencionFields

//region Obra_intervencionManager
class Obra_intervencionManager extends SqfEntityProvider {
  Obra_intervencionManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'obra_intervencion';
  static const List<String> _primaryKeyList = [
    'nroComponente',
    'intervencionId',
    'obraId'
  ];
  static const String _whereStr =
      'nroComponente=? AND intervencionId=? AND obraId=?';
}

//endregion Obra_intervencionManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await MyDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await MyDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await MyDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class MyDbModelSequenceManager extends SqfEntityProvider {
  MyDbModelSequenceManager() : super(MyDbModel());
}
// END OF ENTITIES

// BEGIN CONTROLLERS
// BEGIN CONTROLLER (Obra)
class ObraToCertificadoControllerSub extends CertificadoController {
  static String relationshipFieldName = 'obraId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'nombreRepresentanteOSC';
  //static String formListSubTitleField = '';
}

class ObraToVisitaControllerSub extends VisitaController {
  static String relationshipFieldName = 'obraId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'nombreRepresentanteOSC';
  //static String formListSubTitleField = '';
}

class ObraController extends Obra {
  String formListTitleField = 'nombreRepresentanteOSC';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    ObraController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['ObraToCertificado'] = 'Obra To Certificado(obraId)';
    menu['ObraToVisita'] = 'Obra To Visita(obraId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'ObraToCertificado':
        return SQFViewList(
          ObraToCertificadoControllerSub(),
          primaryKeyName: ObraToCertificadoControllerSub.primaryKeyName,
          useSoftDeleting: ObraToCertificadoControllerSub.useSoftDeleting,
          //formListTitleField: 'nombreRepresentanteOSC',
          //formListSubTitleField: '',
          filterExpression:
              '${ObraToCertificadoControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'ObraToVisita':
        return SQFViewList(
          ObraToVisitaControllerSub(),
          primaryKeyName: ObraToVisitaControllerSub.primaryKeyName,
          useSoftDeleting: ObraToVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'nombreRepresentanteOSC',
          //formListSubTitleField: '',
          filterExpression:
              '${ObraToVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ObraAdd(obj == null
        ? Obra()
        : await Obra().getById(obj['id'] as int) ?? Obra());
  }
}
// END CONTROLLER (Obra)

// BEGIN CONTROLLER (Vivienda)
class ViviendaToRespuestaVisitaControllerSub extends RespuestaVisitaController {
  static String relationshipFieldName = 'viviendaId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'aliasRenabap';
  //static String formListSubTitleField = '';
}

class ViviendaToFotoViviendaControllerSub extends FotoViviendaController {
  static String relationshipFieldName = 'viviendaId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'aliasRenabap';
  //static String formListSubTitleField = '';
}

class ViviendaController extends Vivienda {
  String formListTitleField = 'aliasRenabap';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    ViviendaController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['ViviendaToRespuestaVisita'] =
        'Vivienda To RespuestaVisita(viviendaId)';
    menu['ViviendaToFotoVivienda'] = 'Vivienda To FotoVivienda(viviendaId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'ViviendaToRespuestaVisita':
        return SQFViewList(
          ViviendaToRespuestaVisitaControllerSub(),
          primaryKeyName: ViviendaToRespuestaVisitaControllerSub.primaryKeyName,
          useSoftDeleting:
              ViviendaToRespuestaVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'aliasRenabap',
          //formListSubTitleField: '',
          filterExpression:
              '${ViviendaToRespuestaVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'ViviendaToFotoVivienda':
        return SQFViewList(
          ViviendaToFotoViviendaControllerSub(),
          primaryKeyName: ViviendaToFotoViviendaControllerSub.primaryKeyName,
          useSoftDeleting: ViviendaToFotoViviendaControllerSub.useSoftDeleting,
          //formListTitleField: 'aliasRenabap',
          //formListSubTitleField: '',
          filterExpression:
              '${ViviendaToFotoViviendaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ViviendaAdd(obj == null
        ? Vivienda()
        : await Vivienda().getById(obj['id'] as int) ?? Vivienda());
  }
}
// END CONTROLLER (Vivienda)

// BEGIN CONTROLLER (Certificado)

class CertificadoController extends Certificado {
  String formListTitleField = 'id';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    CertificadoController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return CertificadoAdd(obj == null
        ? Certificado()
        : await Certificado().getById(obj['id'] as int) ?? Certificado());
  }
}
// END CONTROLLER (Certificado)

// BEGIN CONTROLLER (Visita)
class VisitaToRespuestaVisitaControllerSub extends RespuestaVisitaController {
  static String relationshipFieldName = 'visitaId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'nombreRelevador';
  //static String formListSubTitleField = '';
}

class VisitaToFotoVisitaControllerSub extends FotoVisitaController {
  static String relationshipFieldName = 'visitaId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'nombreRelevador';
  //static String formListSubTitleField = '';
}

class VisitaController extends Visita {
  String formListTitleField = 'nombreRelevador';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    VisitaController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['VisitaToRespuestaVisita'] = 'Visita To RespuestaVisita(visitaId)';
    menu['VisitaToFotoVisita'] = 'Visita To FotoVisita(visitaId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'VisitaToRespuestaVisita':
        return SQFViewList(
          VisitaToRespuestaVisitaControllerSub(),
          primaryKeyName: VisitaToRespuestaVisitaControllerSub.primaryKeyName,
          useSoftDeleting: VisitaToRespuestaVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'nombreRelevador',
          //formListSubTitleField: '',
          filterExpression:
              '${VisitaToRespuestaVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'VisitaToFotoVisita':
        return SQFViewList(
          VisitaToFotoVisitaControllerSub(),
          primaryKeyName: VisitaToFotoVisitaControllerSub.primaryKeyName,
          useSoftDeleting: VisitaToFotoVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'nombreRelevador',
          //formListSubTitleField: '',
          filterExpression:
              '${VisitaToFotoVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return VisitaAdd(obj == null
        ? Visita()
        : await Visita().getById(obj['id'] as int) ?? Visita());
  }
}
// END CONTROLLER (Visita)

// BEGIN CONTROLLER (PreguntaVisita)
class PreguntaVisitaToRespuestaVisitaControllerSub
    extends RespuestaVisitaController {
  static String relationshipFieldName = 'preguntaVisitaId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'tipoRespuestaA';
  //static String formListSubTitleField = '';
}

class PreguntaVisitaController extends PreguntaVisita {
  String formListTitleField = 'tipoRespuestaA';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    PreguntaVisitaController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['PreguntaVisitaToRespuestaVisita'] =
        'PreguntaVisita To RespuestaVisita(preguntaVisitaId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'PreguntaVisitaToRespuestaVisita':
        return SQFViewList(
          PreguntaVisitaToRespuestaVisitaControllerSub(),
          primaryKeyName:
              PreguntaVisitaToRespuestaVisitaControllerSub.primaryKeyName,
          useSoftDeleting:
              PreguntaVisitaToRespuestaVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'tipoRespuestaA',
          //formListSubTitleField: '',
          filterExpression:
              '${PreguntaVisitaToRespuestaVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return PreguntaVisitaAdd(obj == null
        ? PreguntaVisita()
        : await PreguntaVisita().getById(obj['id'] as int) ?? PreguntaVisita());
  }
}
// END CONTROLLER (PreguntaVisita)

// BEGIN CONTROLLER (RespuestaVisita)

class RespuestaVisitaController extends RespuestaVisita {
  String formListTitleField = 'respuesta';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    RespuestaVisitaController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return RespuestaVisitaAdd(obj == null
        ? RespuestaVisita()
        : await RespuestaVisita().getById(obj['id'] as int) ??
            RespuestaVisita());
  }
}
// END CONTROLLER (RespuestaVisita)

// BEGIN CONTROLLER (Intervencion)
class IntervencionToPreguntaVisitaControllerSub
    extends PreguntaVisitaController {
  static String relationshipFieldName = 'intervencionId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'nombre';
  //static String formListSubTitleField = '';
}

class IntervencionToFotoVisitaControllerSub extends FotoVisitaController {
  static String relationshipFieldName = 'intervencionId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = true;
  //static String formListTitleField = 'nombre';
  //static String formListSubTitleField = '';
}

class IntervencionController extends Intervencion {
  String formListTitleField = 'nombre';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    IntervencionController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['IntervencionToPreguntaVisita'] =
        'Intervencion To PreguntaVisita(intervencionId)';
    menu['IntervencionToFotoVisita'] =
        'Intervencion To FotoVisita(intervencionId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'IntervencionToPreguntaVisita':
        return SQFViewList(
          IntervencionToPreguntaVisitaControllerSub(),
          primaryKeyName:
              IntervencionToPreguntaVisitaControllerSub.primaryKeyName,
          useSoftDeleting:
              IntervencionToPreguntaVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'nombre',
          //formListSubTitleField: '',
          filterExpression:
              '${IntervencionToPreguntaVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'IntervencionToFotoVisita':
        return SQFViewList(
          IntervencionToFotoVisitaControllerSub(),
          primaryKeyName: IntervencionToFotoVisitaControllerSub.primaryKeyName,
          useSoftDeleting:
              IntervencionToFotoVisitaControllerSub.useSoftDeleting,
          //formListTitleField: 'nombre',
          //formListSubTitleField: '',
          filterExpression:
              '${IntervencionToFotoVisitaControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return IntervencionAdd(obj == null
        ? Intervencion()
        : await Intervencion().getById(obj['id'] as int) ?? Intervencion());
  }
}
// END CONTROLLER (Intervencion)

// BEGIN CONTROLLER (FotoVisita)

class FotoVisitaController extends FotoVisita {
  String formListTitleField = 'id';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    FotoVisitaController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return FotoVisitaAdd(obj == null
        ? FotoVisita()
        : await FotoVisita().getById(obj['id'] as int) ?? FotoVisita());
  }
}
// END CONTROLLER (FotoVisita)

// BEGIN CONTROLLER (FotoVivienda)

class FotoViviendaController extends FotoVivienda {
  String formListTitleField = 'id';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    FotoViviendaController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return FotoViviendaAdd(obj == null
        ? FotoVivienda()
        : await FotoVivienda().getById(obj['id'] as int) ?? FotoVivienda());
  }
}
// END CONTROLLER (FotoVivienda)

// END OF CONTROLLERS
